{"title":"Used as a library by TokenExtensionRouter which provides context and variables (platform, contractsManager) when invoke methods of this contract. Since this contract is designed to be used by delegatecall it doesn't inherit from any contract (except FeatureFeeAdapter) and you should be careful when a need will arise to add more functionality by inheritance, because the contract uses storage scheme from TokenExtensionRouter and it should be preserved. It's responsibilities are to: - create assets (with and without fee), - create token crowdsale and remove them. Some methods might take a fee by TIME tokens.","fileName":"/contracts/assets/extensions/PlatformTokenExtensionGatewayManager.sol","name":"PlatformTokenExtensionGatewayManager","abi":[{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"}],"name":"init","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_crowdsale","type":"address"}],"name":"deleteCrowdsaleCampaign","outputs":[{"name":"result","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32"}],"name":"lookupManager","outputs":[{"name":"manager","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_name","type":"string"},{"name":"_description","type":"string"},{"name":"_value","type":"uint256"},{"name":"_decimals","type":"uint8"},{"name":"_isMint","type":"bool"},{"name":"_feeAddress","type":"address"},{"name":"_feePercent","type":"uint32"},{"name":"_tokenImageIpfsHash","type":"bytes32"}],"name":"createAssetWithFee","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"pendingContractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getRevokeAssetProxy","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_crowdsaleFactoryName","type":"bytes32"}],"name":"createCrowdsaleCampaign","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getTokenFactory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getAssetOwnershipManager","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_name","type":"string"},{"name":"_description","type":"string"},{"name":"_value","type":"uint256"},{"name":"_decimals","type":"uint8"},{"name":"_isMint","type":"bool"},{"name":"_tokenImageIpfsHash","type":"bytes32"}],"name":"createAssetWithoutFee","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"contractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getReissueAssetProxy","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getEventsHistory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback"}],"source":"pragma solidity ^0.4.11;\n\nimport \"./TokenExtensionRouter.sol\";\nimport \"./PlatformTokenExtensionGatewayManagerEmitter.sol\";\nimport \"./../TokenManagementInterface.sol\";\nimport \"../../core/contracts/ContractsManagerInterface.sol\";\nimport \"../../core/platform/ChronoBankPlatformInterface.sol\";\nimport \"../../core/platform/ChronoBankAssetOwnershipManager.sol\";\nimport \"../../core/platform/ChronoBankAssetProxyInterface.sol\";\nimport \"../../core/common/OwnedInterface.sol\";\nimport \"../../core/contracts/ContractsManagerInterface.sol\";\nimport \"../../core/erc20/ERC20ManagerInterface.sol\";\nimport \"../../core/erc20/ERC20Interface.sol\";\nimport \"./../AssetsManagerInterface.sol\";\nimport \"./../FeeInterface.sol\";\nimport \"../../timeholder/FeatureFeeAdapter.sol\";\nimport \"../../core/lib/StringsLib.sol\";\n\ncontract ChronoBankAsset {\n    function init(ChronoBankAssetProxyInterface _proxy) returns (bool);\n}\n\n\ncontract TokenFactory {\n    function createAsset() returns (address);\n    function createAssetWithFee(address owner) returns (address);\n    function createProxy() returns (address);\n}\n\n\ncontract PlatformFactory {\n    function createPlatform(address _eventsHistory, address _owner) returns (address);\n}\n\n\ncontract FactoryProvider {\n    function getTokenFactory() returns (TokenFactory);\n}\n\n\ncontract CrowdsaleManager {\n    function createCrowdsale(address _creator, bytes32 _symbol, bytes32 _factoryName) returns (address, uint);\n    function deleteCrowdsale(address crowdsale) returns (uint);\n}\n\n\ncontract BaseCrowdsale {\n    function getSymbol() constant returns (bytes32);\n}\n\n\ncontract OwnedContract {\n    address public contractOwner;\n}\n\n/**\n* @title Used as a library by TokenExtensionRouter which provides context and variables (platform, contractsManager)\n* when invoke methods of this contract.\n* Since this contract is designed to be used by delegatecall it doesn't inherit from any contract (except FeatureFeeAdapter)\n* and you should be careful when a need will arise to add more functionality by inheritance, because the contract uses\n* storage scheme from TokenExtensionRouter and it should be preserved.\n\n* It's responsibilities are to:\n* - create assets (with and without fee),\n* - create token crowdsale and remove them.\n\n* Some methods might take a fee by TIME tokens.\n*/\ncontract PlatformTokenExtensionGatewayManager is FeatureFeeAdapter {\n    uint constant UNAUTHORIZED = 0;\n    uint constant OK = 1;\n    uint constant REINITIALIZED = 6;\n    uint constant ERROR_TOKEN_EXTENSION_ASSET_TOKEN_EXISTS = 23001;\n    uint constant ERROR_TOKEN_EXTENSION_ASSET_COULD_NOT_BE_REISSUED = 23002;\n    uint constant ERROR_TOKEN_EXTENSION_ASSET_COULD_NOT_BE_REVOKED = 23003;\n    uint constant ERROR_TOKEN_EXTENSION_ASSET_OWNER_ONLY = 23004;\n\n    /** @dev platform address. It is initialized only by delegatecall context */\n    address internal contractsManager;\n\n    /** @dev platform address. It is initialized only by delegatecall context and 0x0 in other cases */\n    address internal platform;\n\n    /**\n     * Contract owner address\n     */\n    address public contractOwner;\n\n    /**\n     * Contract owner address\n     */\n    address public pendingContractOwner;\n\n    function PlatformTokenExtensionGatewayManager() {\n        contractOwner = msg.sender;\n    }\n\n    /**\n    * @dev Owner check modifier\n    */\n    modifier onlyContractOwner {\n        if (contractOwner == msg.sender) {\n            _;\n        }\n    }\n\n    /**\n    * @dev Guards methods to be called only by platform owner.\n    */\n    modifier onlyPlatformOwner {\n        if (OwnedContract(platform).contractOwner() == msg.sender ||\n            msg.sender == address(this)) {\n            _;\n        }\n    }\n\n    /**\n    * @dev Guards methods to be called only by platform itself.\n    *\n    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    */\n    modifier onlyPlatform {\n        if (msg.sender == platform ||\n            msg.sender == address(this)) {\n            _;\n        }\n    }\n\n    /**\n    *  @dev Designed to be used by ancestors, inits internal fields.\n    *  Will rollback transaction if something goes wrong during initialization.\n    *  Registers contract as a service in ContractManager with given `_type`.\n    *\n    *  @param _contractsManager is contract manager, must be not 0x0\n    *  @return OK if newly initialized and everything is OK,\n    *  or REINITIALIZED if storage already contains some data. Will crash in any other cases.\n    */\n    function init(address _contractsManager) onlyContractOwner public returns (uint resultCode) {\n        require(_contractsManager != 0x0);\n\n        bool reinitialized = (contractsManager != 0x0);\n        if (contractsManager == 0x0 || contractsManager != _contractsManager) {\n            contractsManager = _contractsManager;\n        }\n\n        assert(OK == ContractsManagerInterface(contractsManager).addContract(this, \"TokenExtensionGateway\"));\n\n        return !reinitialized ? OK : REINITIALIZED;\n    }\n\n    function getEventsHistory() public constant returns (address) {\n        return lookupManager(\"MultiEventsHistory\");\n    }\n\n    /**\n     * @dev Destroy contract and scrub a data\n     * @notice Only owner can call it\n     */\n    function destroy() onlyContractOwner public {\n        ContractsManagerInterface(contractsManager).removeContract(this);\n        selfdestruct(msg.sender);\n    }\n\n    /**\n     * Prepares ownership pass.\n     *\n     * Can only be called by current owner.\n     *\n     * @param _to address of the next owner. 0x0 is not allowed.\n     *\n     * @return success.\n     */\n    function changeContractOwnership(address _to) onlyContractOwner public returns (bool) {\n        if (_to == 0x0) {\n            return false;\n        }\n\n        pendingContractOwner = _to;\n        return true;\n    }\n\n    /**\n     * Finalize ownership pass.\n     *\n     * Can only be called by pending owner.\n     *\n     * @return success.\n     */\n    function claimContractOwnership() public returns (bool) {\n        if (pendingContractOwner != msg.sender) {\n            return false;\n        }\n\n        contractOwner = pendingContractOwner;\n        delete pendingContractOwner;\n\n        return true;\n    }\n\n    /**\n    * @dev Direct ownership pass without change/claim pattern. Can be invoked only by current contract owner\n    *\n    * @param _to the next contract owner\n    *\n    * @return `true` if success, `false` otherwise\n    */\n    function transferContractOwnership(address _to) onlyContractOwner public returns (bool) {\n        if (_to == 0x0) {\n            return false;\n        }\n\n        if (pendingContractOwner != 0x0) {\n            pendingContractOwner = 0x0;\n        }\n\n        contractOwner = _to;\n        return true;\n    }\n\n    /**\n    * @dev Creates asset without fee. Performs asset registration in ERC20Manager.\n    * Allowed to be performed only from delegatecall and only by platform owner.\n    * Might take an additional fee in TIME tokens\n    *\n    * @param _symbol new asset's symbol\n    * @param _name asset's name\n    * @param _description description of an asset\n    * @param _value initial balance to issue\n    * @param _decimals decimals\n    * @param _isMint is reissuable\n    * @param _tokenImageIpfsHash asset image IPFS hash\n    *\n    * @return resultCode result code of an operation\n    */\n    function createAssetWithoutFee(\n        bytes32 _symbol,\n        string _name,\n        string _description,\n        uint _value,\n        uint8 _decimals,\n        bool _isMint,\n        bytes32 _tokenImageIpfsHash)\n    onlyPlatformOwner\n    public\n    returns (uint resultCode)\n    {\n        return _createAssetWithoutFee(_symbol, _name, _description, _value, _decimals, _isMint, _tokenImageIpfsHash, [uint(0)]);\n    }\n\n    function _createAssetWithoutFee(\n        bytes32 _symbol,\n        string _name,\n        string _description,\n        uint _value,\n        uint8 _decimals,\n        bool _isMint,\n        bytes32 _tokenImageIpfsHash,\n        uint[1] memory _result)\n    featured(_result)\n    private\n    returns (uint resultCode)\n    {\n        resultCode = _prepareAndIssueAssetOnPlatform(_symbol, _name, _description, _value, _decimals, _isMint);\n        if (resultCode != OK) {\n            return _emitError(resultCode);\n        }\n\n        address _asset = _createAsset(getTokenFactory());\n        address _token = _bindAssetWithToken(getTokenFactory(), _asset, _symbol, _name, _decimals, _tokenImageIpfsHash);\n\n        _emitAssetCreated(platform, _symbol, _token, msg.sender);\n\n        _result[0] = OK;\n        return OK;\n    }\n\n\n    /**\n    * @dev Creates asset with fee. Performs asset registration in ERC20Manager.\n    * Allowed to be performed only from delegatecall and only by platform owner.\n    * Might take an additional fee in TIME tokens\n    *\n    * @param _symbol new asset's symbol\n    * @param _name asset's name\n    * @param _description description of an asset\n    * @param _value initial balance to issue\n    * @param _decimals decimals\n    * @param _isMint is reissuable\n    * @param _feeAddress fee wallet address\n    * @param _feePercent fee percent value\n    * @param _tokenImageIpfsHash asset image IPFS hash\n    *\n    * @return resultCode result code of an operation\n    */\n    function createAssetWithFee(\n        bytes32 _symbol,\n        string _name,\n        string _description,\n        uint _value,\n        uint8 _decimals,\n        bool _isMint,\n        address _feeAddress,\n        uint32 _feePercent,\n        bytes32 _tokenImageIpfsHash)\n    onlyPlatformOwner\n    public\n    returns (uint resultCode) {\n        return _createAssetWithFee(_symbol, _name, _description, _value, _decimals, _isMint, _feeAddress, _feePercent, _tokenImageIpfsHash, [uint(0)]);\n    }\n\n    function _createAssetWithFee(\n        bytes32 _symbol,\n        string _name,\n        string _description,\n        uint _value,\n        uint8 _decimals,\n        bool _isMint,\n        address _feeAddress,\n        uint32 _feePercent,\n        bytes32 _tokenImageIpfsHash,\n        uint[1] memory _result)\n    featured(_result)\n    private\n    returns (uint resultCode)\n    {\n        require(_feeAddress != 0x0);\n\n        resultCode = _prepareAndIssueAssetOnPlatform(_symbol, _name, _description, _value, _decimals, _isMint);\n        if (resultCode != OK) {\n            return _emitError(resultCode);\n        }\n\n        address _token = _bindAssetWithToken(getTokenFactory(), _deployAssetWithFee(getTokenFactory(), _feeAddress, _feePercent), _symbol, _name, _decimals, _tokenImageIpfsHash);\n        _emitAssetCreated(platform, _symbol, _token, msg.sender);\n\n        _result[0] = OK;\n        return OK;\n    }\n\n\n    /**\n    * @dev Gets token and proxy factory\n    *\n    * @return factory address\n    */\n    function getTokenFactory() constant returns (TokenFactory) {\n        return FactoryProvider(lookupManager(\"AssetsManager\")).getTokenFactory();\n    }\n\n    /**\n    * @dev Creates crowdsale campaign of a token with provided symbol\n    * Might take an additional fee in TIME tokens\n    *\n    * @param _symbol a token symbol\n    *\n    * @return result code of an operation\n    */\n    function createCrowdsaleCampaign(bytes32 _symbol, bytes32 _crowdsaleFactoryName)\n    onlyPlatformOwner\n    public\n    returns (uint)\n    {\n        return _createCrowdsaleCampaign(_symbol, _crowdsaleFactoryName, [uint(0)]);\n    }\n\n    function _createCrowdsaleCampaign(\n        bytes32 _symbol,\n        bytes32 _crowdsaleFactoryName,\n        uint[1] memory _result)\n    featured(_result)\n    private\n    returns (uint)\n    {\n        require(_symbol != 0x0);\n        require(_crowdsaleFactoryName != 0x0);\n\n        ChronoBankAssetOwnershipManager _assetOwnershipManager = ChronoBankAssetOwnershipManager(getAssetOwnershipManager());\n        CrowdsaleManager crowdsaleManager = CrowdsaleManager(lookupManager(\"CrowdsaleManager\"));\n\n        var (_crowdsale, result) = crowdsaleManager.createCrowdsale(msg.sender, _symbol, _crowdsaleFactoryName);\n        if (result != OK) {\n            return _emitError(result);\n        }\n\n        if( OK != _assetOwnershipManager.addAssetPartOwner(_symbol, _crowdsale)) revert();\n\n        _emitCrowdsaleCampaignCreated(platform, _symbol, _crowdsale, msg.sender);\n\n        _result[0] = OK;\n        return OK;\n    }\n\n    /**\n    * @dev Stops token's crowdsale\n    *\n    * @param _crowdsale a crowdsale address\n    *\n    * @return result result code of an operation\n    */\n    function deleteCrowdsaleCampaign(address _crowdsale) onlyPlatformOwner public returns (uint result) {\n        bytes32 _symbol = BaseCrowdsale(_crowdsale).getSymbol();\n        ChronoBankAssetOwnershipManager _assetOwnershipManager = ChronoBankAssetOwnershipManager(getAssetOwnershipManager());\n\n        CrowdsaleManager crowdsaleManager = CrowdsaleManager(lookupManager(\"CrowdsaleManager\"));\n\n        result = crowdsaleManager.deleteCrowdsale(_crowdsale);\n        if (result != OK) {\n            return _emitError(result);\n        }\n\n        if(OK != _assetOwnershipManager.removeAssetPartOwner(_symbol, _crowdsale)) revert();\n\n        _emitCrowdsaleCampaignRemoved(platform, _symbol, _crowdsale, msg.sender);\n        return OK;\n    }\n\n    /**\n    * @dev Gets an interface for managing assets' ownership\n    *\n    * @return interface of assets ownership manager\n    */\n    function getAssetOwnershipManager() public constant returns (address) {\n        return platform;\n    }\n\n    /**\n    * @dev Gets a proxy where possible to reissue assets\n    *\n    * @return interface for reissuing assets\n    */\n    function getReissueAssetProxy() public constant returns (ReissuableAssetProxyInterface) {\n        return ReissuableAssetProxyInterface(platform);\n    }\n\n    /**\n    * @dev Gets a proxy where possible to revoke assets\n    *\n    * @return interface for revoking assets\n    */\n    function getRevokeAssetProxy() public constant returns (RevokableAssetProxyInterface) {\n        return RevokableAssetProxyInterface(platform);\n    }\n\n    /**\n    * @dev Checks symbol for existance in the system and issue new asset. PRIVATE\n    */\n    function _prepareAndIssueAssetOnPlatform(bytes32 _symbol, string _name, string _description, uint _value, uint8 _decimals, bool _isMint) private returns (uint) {\n        ERC20ManagerInterface _erc20Manager = ERC20ManagerInterface(lookupManager(\"ERC20Manager\"));\n        if (_erc20Manager.getTokenAddressBySymbol(_symbol) != 0x0) {\n            return ERROR_TOKEN_EXTENSION_ASSET_TOKEN_EXISTS;\n        }\n\n        return ChronoBankPlatformInterface(platform).issueAsset(_symbol, _value, _name, _description, _decimals, _isMint, msg.sender);\n    }\n\n    /**\n    * @dev Binds asset with proxy and register it in ERC20Manager. PRIVATE\n    */\n    function _bindAssetWithToken(TokenFactory _factory, address _asset, bytes32 _symbol, string _name, uint8 _decimals, bytes32 _ipfsHash) private returns (address token) {\n        token = _factory.createProxy();\n\n        if (OK != ChronoBankPlatformInterface(platform).setProxy(token, _symbol)) revert();\n\n        ChronoBankAssetOwnershipManager _assetOwnershipManager = ChronoBankAssetOwnershipManager(getAssetOwnershipManager());\n        ChronoBankAssetProxyInterface(token).init(platform, StringsLib.bytes32ToString(_symbol), _name);\n        ChronoBankAssetProxyInterface(token).proposeUpgrade(_asset);\n        ChronoBankAsset(_asset).init(ChronoBankAssetProxyInterface(token));\n        if (OK != _assetOwnershipManager.addAssetPartOwner(_symbol, this)) revert();\n        _assetOwnershipManager.changeOwnership(_symbol, msg.sender);\n\n        if(OK != _addToken(token, _symbol, _decimals, _ipfsHash)) revert();\n    }\n\n    /**\n    * @dev Creates asset with fee and setup according values. PRIVATE\n    *\n    * @param _factory token factory\n    * @param _feeAddress fee destination address\n    * @param _fee fee percent value\n    */\n    function _deployAssetWithFee(TokenFactory _factory, address _feeAddress, uint32 _fee) private returns (address _asset) {\n        _asset = _factory.createAssetWithFee(this);\n        FeeInterface(_asset).setupFee(_feeAddress, _fee);\n        OwnedInterface(_asset).transferContractOwnership(msg.sender);\n    }\n\n    /**\n    * @dev Creates asset without fee. PRIVATE\n    *\n    * @param _factory token factory\n    *\n    * @return _asset created asset address\n    */\n    function _createAsset(TokenFactory _factory) private returns (address _asset) {\n        _asset = _factory.createAsset();\n    }\n\n    /**\n    * Adds token to ERC20Manager contract\n    * @dev Make as a separate function because of stack size limits\n    *\n    * @param token token's address\n    * @param symbol asset's symbol\n    * @param decimals number of digits after floating point\n    *\n    * @return errorCode result code of an operation\n    */\n    function _addToken(address token, bytes32 symbol, uint8 decimals, bytes32 _ipfsHash) private returns (uint errorCode) {\n        ERC20ManagerInterface erc20Manager = ERC20ManagerInterface(lookupManager(\"ERC20Manager\"));\n        errorCode = erc20Manager.addToken(token, bytes32(0), symbol, bytes32(0), decimals, _ipfsHash, bytes32(0));\n    }\n\n    /**\n    * @dev Makes search in contractsManager for registered contract by some identifier\n    *\n    * @param _identifier string identifier of a manager\n    *\n    * @return manager address of a manager, 0x0 if nothing was found\n    */\n    function lookupManager(bytes32 _identifier) constant returns (address manager) {\n        manager = ContractsManagerInterface(contractsManager).getContractAddressByType(_identifier);\n        assert(manager != 0x0);\n    }\n\n\n    /**\n    * Events emitting\n    */\n\n    function _emitError(uint _errorCode) internal returns (uint) {\n        PlatformTokenExtensionGatewayManagerEmitter(getEventsHistory()).emitError(_errorCode);\n        return _errorCode;\n    }\n\n    function _emitAssetCreated(address _platform, bytes32 _symbol, address _token, address _by) private {\n        PlatformTokenExtensionGatewayManagerEmitter(getEventsHistory()).emitAssetCreated(_platform, _symbol, _token, _by);\n    }\n\n    function _emitCrowdsaleCampaignCreated(address _platform, bytes32 _symbol, address _campaign, address _by) private {\n        PlatformTokenExtensionGatewayManagerEmitter(getEventsHistory()).emitCrowdsaleCampaignCreated(_platform, _symbol, _campaign, _by);\n    }\n\n    function _emitCrowdsaleCampaignRemoved(address _platform, bytes32 _symbol, address _campaign, address _by) private {\n        PlatformTokenExtensionGatewayManagerEmitter(getEventsHistory()).emitCrowdsaleCampaignRemoved(_platform, _symbol, _campaign, _by);\n    }\n\n    function () public {\n        revert();\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[{"name":"_contractsManager","type":"address","description":"is contract manager, must be not 0x0"}],"name":"init","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Designed to be used by ancestors, inits internal fields. Will rollback transaction if something goes wrong during initialization. Registers contract as a service in ContractManager with given `_type`.","return":"OK if newly initialized and everything is OK, or REINITIALIZED if storage already contains some data. Will crash in any other cases.","signature":"init(address)","signatureHash":"19ab453c"},{"constant":false,"inputs":[{"name":"_crowdsale","type":"address","description":"a crowdsale address"}],"name":"deleteCrowdsaleCampaign","outputs":[{"name":"result","type":"uint256","description":"result code of an operation"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Stops token's crowdsale","return":"result result code of an operation","signature":"deleteCrowdsaleCampaign(address)","signatureHash":"25115a36"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Finalize ownership pass.     * Can only be called by pending owner.","signature":"claimContractOwnership()","signatureHash":"4592cd1d"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32","description":"string identifier of a manager"}],"name":"lookupManager","outputs":[{"name":"manager","type":"address","description":"address of a manager, 0x0 if nothing was found"}],"payable":false,"stateMutability":"view","type":"function","details":"Makes search in contractsManager for registered contract by some identifier","return":"manager address of a manager, 0x0 if nothing was found","signature":"lookupManager(bytes32)","signatureHash":"4fe59012"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"address of the next owner. 0x0 is not allowed."}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Prepares ownership pass.     * Can only be called by current owner.","signature":"changeContractOwnership(address)","signatureHash":"557f4bc9"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"new asset's symbol"},{"name":"_name","type":"string","description":"asset's name"},{"name":"_description","type":"string","description":"description of an asset"},{"name":"_value","type":"uint256","description":"initial balance to issue"},{"name":"_decimals","type":"uint8","description":"decimals"},{"name":"_isMint","type":"bool","description":"is reissuable"},{"name":"_feeAddress","type":"address","description":"fee wallet address"},{"name":"_feePercent","type":"uint32","description":"fee percent value"},{"name":"_tokenImageIpfsHash","type":"bytes32","description":"asset image IPFS hash"}],"name":"createAssetWithFee","outputs":[{"name":"resultCode","type":"uint256","description":"result code of an operation"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Creates asset with fee. Performs asset registration in ERC20Manager. Allowed to be performed only from delegatecall and only by platform owner. Might take an additional fee in TIME tokens","return":"resultCode result code of an operation","signature":"createAssetWithFee(bytes32,string,string,uint256,uint8,bool,address,uint32,bytes32)","signatureHash":"58d261f2"},{"constant":true,"inputs":[],"name":"pendingContractOwner","payable":false,"stateMutability":"view","type":"function","signature":"pendingContractOwner()","signatureHash":"5aa77d3c"},{"constant":true,"inputs":[],"name":"getRevokeAssetProxy","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets a proxy where possible to revoke assets","return":"interface for revoking assets","signature":"getRevokeAssetProxy()","signatureHash":"698f7683"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"a token symbol"},{"name":"_crowdsaleFactoryName","type":"bytes32"}],"name":"createCrowdsaleCampaign","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Creates crowdsale campaign of a token with provided symbol Might take an additional fee in TIME tokens","return":"result code of an operation","signature":"createCrowdsaleCampaign(bytes32,bytes32)","signatureHash":"76d064d7"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Destroy contract and scrub a data","notice":"Only owner can call it","signature":"destroy()","signatureHash":"83197ef0"},{"constant":true,"inputs":[],"name":"getTokenFactory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets token and proxy factory","return":"factory address","signature":"getTokenFactory()","signatureHash":"925d6ba2"},{"constant":true,"inputs":[],"name":"getAssetOwnershipManager","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets an interface for managing assets' ownership","return":"interface of assets ownership manager","signature":"getAssetOwnershipManager()","signatureHash":"94d0169f"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"the next contract owner"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Direct ownership pass without change/claim pattern. Can be invoked only by current contract owner","return":"`true` if success, `false` otherwise","signature":"transferContractOwnership(address)","signatureHash":"a843c51f"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"new asset's symbol"},{"name":"_name","type":"string","description":"asset's name"},{"name":"_description","type":"string","description":"description of an asset"},{"name":"_value","type":"uint256","description":"initial balance to issue"},{"name":"_decimals","type":"uint8","description":"decimals"},{"name":"_isMint","type":"bool","description":"is reissuable"},{"name":"_tokenImageIpfsHash","type":"bytes32","description":"asset image IPFS hash"}],"name":"createAssetWithoutFee","outputs":[{"name":"resultCode","type":"uint256","description":"result code of an operation"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Creates asset without fee. Performs asset registration in ERC20Manager. Allowed to be performed only from delegatecall and only by platform owner. Might take an additional fee in TIME tokens","return":"resultCode result code of an operation","signature":"createAssetWithoutFee(bytes32,string,string,uint256,uint8,bool,bytes32)","signatureHash":"b3a31ef4"},{"constant":true,"inputs":[],"name":"contractOwner","payable":false,"stateMutability":"view","type":"function","signature":"contractOwner()","signatureHash":"ce606ee0"},{"constant":true,"inputs":[],"name":"getReissueAssetProxy","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets a proxy where possible to reissue assets","return":"interface for reissuing assets","signature":"getReissueAssetProxy()","signatureHash":"d363228f"},{"constant":true,"inputs":[],"name":"getEventsHistory","payable":false,"stateMutability":"view","type":"function","signature":"getEventsHistory()","signatureHash":"fff10aba"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback","inputs":[]}]}
