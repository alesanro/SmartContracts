{"title":"AssetsManager is a helper contract which allows centralized access to tokens' management on top of chronobank platforms. It is used in pair with PlatformsManager and provides a creation of token extensions for platforms. Contract also has methods for quick access to token info such as: - token address by symbol, - if token exists in a system, - if a user is a owner of a token.","fileName":"/contracts/assets/AssetsManager.sol","name":"AssetsManager","abi":[{"constant":true,"inputs":[{"name":"_platform","type":"address"},{"name":"_owner","type":"address"}],"name":"getAssetsForOwnerCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"},{"name":"_tokenExtensionFactory","type":"address"},{"name":"_tokenFactory","type":"address"}],"name":"init","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_user","type":"address"}],"name":"isAssetOwner","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_platform","type":"address"},{"name":"_owner","type":"address"}],"name":"assetOwnerRemoved","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"getAssetBySymbol","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_platform","type":"address"},{"name":"_owner","type":"address"},{"name":"_idx","type":"uint256"}],"name":"getAssetForOwnerAtIndex","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_tokenExtension","type":"address"}],"name":"emitTokenExtensionUnregistered","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokenFactory","type":"address"}],"name":"setTokenFactory","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"getManagers","outputs":[{"name":"","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getTokenExtensionFactory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32"}],"name":"lookupManager","outputs":[{"name":"manager","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"contractsManager","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"getSystemAssetsForOwnerCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"pendingContractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_platform","type":"address"},{"name":"_owner","type":"address"}],"name":"assetOwnerAdded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"getSystemAssetsForOwner","outputs":[{"name":"_tokens","type":"address[]"},{"name":"_tokenPlatforms","type":"address[]"},{"name":"_totalSupplies","type":"uint256[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_tokenExtension","type":"address"}],"name":"containsTokenExtension","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokenExtension","type":"address"}],"name":"registerTokenExtension","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_tokenExtension","type":"address"}],"name":"emitTokenExtensionRegistered","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getTokenFactory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_tokenExtension","type":"address"}],"name":"emitTokenExtensionRequested","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokenExtensionFactory","type":"address"}],"name":"setTokenExtensionFactory","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"getManagersForAssetSymbol","outputs":[{"name":"_managers","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_platform","type":"address"}],"name":"requestTokenExtension","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"contractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"getParticipatingPlatformsForUser","outputs":[{"name":"_platforms","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"isAssetSymbolExists","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_tokenExtension","type":"address"}],"name":"unregisterTokenExtension","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"errorCode","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_platform","type":"address"}],"name":"getTokenExtension","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getEventsHistory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":false,"name":"tokenExtension","type":"address"}],"name":"TokenExtensionRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":false,"name":"tokenExtension","type":"address"}],"name":"TokenExtensionRegistered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"tokenExtension","type":"address"}],"name":"TokenExtensionUnregistered","type":"event"}],"source":"pragma solidity ^0.4.11;\n\nimport \"../core/common/BaseManager.sol\";\nimport \"../core/common/Once.sol\";\nimport \"../core/erc20/ERC20ManagerInterface.sol\";\nimport \"../core/platform/ChronoBankAssetProxyInterface.sol\";\nimport \"../core/platform/ChronoBankAssetOwnershipManager.sol\";\nimport \"../core/platform/ChronoBankPlatformInterface.sol\";\nimport \"../core/platform/ChronoBankPlatform.sol\";\nimport \"./TokenManagementInterface.sol\";\nimport \"./AssetsManagerInterface.sol\";\nimport \"./AssetsManagerEmitter.sol\";\nimport \"./PlatformsManagerInterface.sol\";\nimport \"../core/lib/AssetsManagerAggregations.sol\";\n\ncontract OwnedContract {\n    address public contractOwner;\n}\n\n\ncontract TokenExtensionsFactory {\n    function createTokenExtension(address _platform) returns (address);\n}\n\n\ncontract EventsHistory {\n    function authorize(address _eventEmitter) returns (bool);\n    function reject(address _eventEmitter);\n}\n\n\n/**\n* @title AssetsManager is a helper contract which allows centralized access to tokens' management\n* on top of chronobank platforms. It is used in pair with PlatformsManager and provides\n* a creation of token extensions for platforms.\n* Contract also has methods for quick access to token info such as:\n* - token address by symbol,\n* - if token exists in a system,\n* - if a user is a owner of a token.\n*\n* @dev This contract contains statistics getters but they are deprecated and will be removed soon.\n*\n*/\ncontract AssetsManager is AssetsManagerInterface, TokenExtensionRegistry, AssetOwningListener, BaseManager, AssetsManagerEmitter {\n\n    /** Error codes */\n\n    uint constant ERROR_ASSETS_MANAGER_SYMBOL_ALREADY_EXISTS = 30001;\n    uint constant ERROR_ASSETS_MANAGER_INVALID_INVOCATION = 30002;\n    uint constant ERROR_ASSETS_MANAGER_EXTENSION_ALREADY_EXISTS = 30003;\n\n    /** Storage keys */\n\n    /** @dev address of a token extension factory contract  */\n    StorageInterface.Address tokenExtensionFactory;\n\n    /** @dev address of a token and proxy factory contract */\n    StorageInterface.Address tokenFactory;\n\n    /** @dev mapping (address => address) stands for (platform => tokenExtension) */\n    StorageInterface.AddressAddressMapping platformToExtension;\n\n    /** @dev collection of addresses of token extensions registered in AssetsManager */\n    StorageInterface.OrderedAddressesSet tokenExtensions;\n\n    /** @dev mapping (address => set(address)) stands for (user => set(platform)) */\n    StorageInterface.AddressesSetMapping userToParticipatedPlatforms;\n\n    /** @dev mapping (bytes32 => set(bytes32)) stands for (hash(user,platform) => set(tokenSymbol)) */\n    StorageInterface.Bytes32SetMapping userWithPlatformToOwnedSymbols;\n\n    /** @dev mapping (bytes32 => set(address)) stands for (hash(tokenSymbol,platform) => set(user)) */\n    StorageInterface.AddressesSetMapping symbolWithPlatformToUsers;\n\n    /**\n    * @dev Guards methods for callers that are owners of a platform\n    */\n    modifier onlyPlatformOwner(address _platform) {\n        if (OwnedContract(_platform).contractOwner() == msg.sender) {\n            _;\n        }\n    }\n\n    /**\n    * @dev Guards methods where caller is AssetOwnershipResolver\n    */\n    modifier onlyResolver {\n        if (lookupManager(\"AssetOwnershipResolver\") == msg.sender) {\n            _;\n        }\n    }\n\n    /**\n    * Constructor function\n    *\n    * @param _store link to a global storage\n    * @param _crate namespace in a storage\n    */\n    function AssetsManager(Storage _store, bytes32 _crate) BaseManager(_store, _crate) {\n        tokenExtensionFactory.init(\"tokenExtensionFactory\");\n        tokenFactory.init(\"tokenFactory\");\n        platformToExtension.init(\"v1platformToExtension\");\n        tokenExtensions.init(\"v1tokenExtensions\");\n        userToParticipatedPlatforms.init(\"v1userToParticipatedPlatforms\");\n        userWithPlatformToOwnedSymbols.init(\"v1userWithPlatformToOwnedSymbols\");\n        symbolWithPlatformToUsers.init(\"v1symbolWithPlatformToUsers\");\n    }\n\n    /**\n    * @dev Initalizer. Used by contract owner to initialize and re-initialize contract after deploying new versions\n    * of related dependencies.\n    *\n    * @param _contractsManager contracts manager\n    * @param _tokenExtensionFactory token extension factory address\n    * @param _tokenFactory token and proxy factory address\n    *\n    * @return result code of an operation. `OK` if all went well\n    */\n    function init(address _contractsManager, address _tokenExtensionFactory, address _tokenFactory) onlyContractOwner public returns (uint) {\n        BaseManager.init(_contractsManager, \"AssetsManager\");\n        setTokenExtensionFactory(_tokenExtensionFactory);\n        setTokenFactory(_tokenFactory);\n\n        return OK;\n    }\n\n    /**\n    * @dev Gets an address of currenty used token extension factory\n    *\n    * @return address of a factory\n    */\n    function getTokenExtensionFactory() public constant returns (address) {\n        return store.get(tokenExtensionFactory);\n    }\n\n    /**\n    * @dev Sets a new address of token extension factory contract as currently used in AssetsManager\n    *\n    * @param _tokenExtensionFactory address of an updated token extension factory contract\n    *\n    * @return result code of an operation. `OK` if all went well\n    */\n    function setTokenExtensionFactory(address _tokenExtensionFactory) onlyContractOwner public returns (uint) {\n        require(_tokenExtensionFactory != 0x0);\n\n        store.set(tokenExtensionFactory, _tokenExtensionFactory);\n        return OK;\n    }\n\n    /**\n    * @dev Gets an address of currenty used token and proxy factory\n    *\n    * @return address of a factory\n    */\n    function getTokenFactory() public constant returns (address) {\n        return store.get(tokenFactory);\n    }\n\n    /**\n    * @dev Sets a new address of token and proxy factory contract as currently used in AssetsManager\n    *\n    * @param _tokenFactory address of an updated token and proxy factory contract\n    *\n    * @return result code of an operation. `OK` if all went well\n    */\n    function setTokenFactory(address _tokenFactory) onlyContractOwner public returns (uint) {\n        require(_tokenFactory != 0x0);\n\n        store.set(tokenFactory, _tokenFactory);\n        return OK;\n    }\n\n    /**\n    * @dev Checks if a provided token extension address is a part of the system\n    *\n    * @param _tokenExtension address of a token extension\n    *\n    * @return `true` if a token extension is inside AssetsManager, `false` otherwise\n    */\n    function containsTokenExtension(address _tokenExtension) public constant returns (bool) {\n        return store.includes(tokenExtensions, _tokenExtension);\n    }\n\n    /**\n    * @dev Implements AssetOwningListener interface to provide an ability to track asset ownership\n    * from chronobank platforms.\n    * Should be called when new owner of a symbol is added in a platform.\n    * Allowed to be invoked only by AssetOwnershipResolver.\n    *\n    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    *\n    * @param _symbol token's associated symbol\n    * @param _platform address of a platform where asset's ownership had changed\n    * @param _owner user which was added as an owner of the token\n    */\n    function assetOwnerAdded(bytes32 _symbol, address _platform, address _owner) onlyResolver public {\n        bytes32 _symbolKey = keccak256(_owner, _platform);\n        if (store.includes(userWithPlatformToOwnedSymbols, _symbolKey, _symbol)) {\n            return;\n        }\n\n        store.add(userToParticipatedPlatforms, bytes32(_owner), _platform);\n        store.add(userWithPlatformToOwnedSymbols, _symbolKey, _symbol);\n        store.add(symbolWithPlatformToUsers, keccak256(_symbol, _platform), _owner);\n    }\n\n    /**\n    * @dev Implements AssetOwningListener interface to provide an ability to track asset ownership\n    * from chronobank platforms.\n    * Should be called when an existed owner of a symbol is removed in a platform.\n    * Allowed to be invoked only by AssetOwnershipResolver.\n    *\n    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    *\n    * @param _symbol token's associated symbol\n    * @param _platform address of a platform where asset's ownership had changed\n    * @param _owner user which was removed from the token's ownership\n    */\n    function assetOwnerRemoved(bytes32 _symbol, address _platform, address _owner) onlyResolver public {\n        bytes32 _symbolKey = keccak256(_owner, _platform);\n        if (!store.includes(userWithPlatformToOwnedSymbols, _symbolKey, _symbol)) {\n            return;\n        }\n\n        store.remove(userWithPlatformToOwnedSymbols, _symbolKey, _symbol);\n\n        if (store.count(userWithPlatformToOwnedSymbols, _symbolKey) == 0) {\n            store.remove(userToParticipatedPlatforms, bytes32(_owner), _platform);\n        }\n        store.remove(symbolWithPlatformToUsers, keccak256(_symbol, _platform), _owner);\n    }\n\n    /**\n    * @dev Registers and stores token extension of a platform into the system. Mostly this method should be used\n    * when platform's token extention was removed manually from AssetsManager or there was no token extension at all.\n    * It is preferred to create token extension by calling requestTokenExtension: this will ensure that the latest\n    * version of token extension contract will be used.\n    * There might be ONLY ONE token extension at a time associated with a platform and be registered in the system.\n    * Can be used only by platform's owner associated with this token extension.\n    *\n    * @param _tokenExtension address of token extension\n    *\n    * @return result code of an operation. ERROR_ASSETS_MANAGER_EXTENSION_ALREADY_EXISTS, ERROR_ASSETS_MANAGER_EXTENSION_ALREADY_EXISTS\n    *           might be returned.\n    */\n    function registerTokenExtension(address _tokenExtension) onlyPlatformOwner(TokenManagementInterface(_tokenExtension).platform()) public returns (uint) {\n        if (store.includes(tokenExtensions, _tokenExtension)) {\n            return _emitError(ERROR_ASSETS_MANAGER_EXTENSION_ALREADY_EXISTS);\n        }\n\n        address _platform = TokenManagementInterface(_tokenExtension).platform();\n        if (store.get(platformToExtension, _platform) != 0x0) {\n            return _emitError(ERROR_ASSETS_MANAGER_EXTENSION_ALREADY_EXISTS);\n        }\n\n        _setupTokenExtension(_platform, _tokenExtension);\n        _emitTokenExtensionRegistered(_platform, _tokenExtension);\n        return OK;\n    }\n\n    /**\n    * @dev Unregisters and removes token extension from the system. It should be used when you know what are you doing,\n    * because it will remove record of token extension for a platform and to continue using an associated token extension\n    * with platform you should register a new token extension address or request a brand new one (see `requestTokenExtension` method).\n    * Can be used only by platform's owner associated with this token extension.\n    *\n    * @param _tokenExtension address of a token extension\n    *\n    * @return result code of an operation. ERROR_ASSETS_MANAGER_INVALID_INVOCATION might be returned.\n    */\n    function unregisterTokenExtension(address _tokenExtension) onlyPlatformOwner(TokenManagementInterface(_tokenExtension).platform()) public returns (uint) {\n        if (!store.includes(tokenExtensions, _tokenExtension)) {\n            return _emitError(ERROR_ASSETS_MANAGER_INVALID_INVOCATION);\n        }\n\n        store.remove(tokenExtensions, _tokenExtension);\n        store.set(platformToExtension, TokenManagementInterface(_tokenExtension).platform(), 0x0);\n        EventsHistory(getEventsHistory()).reject(_tokenExtension);\n\n        _emitTokenExtensionUnregistered(_tokenExtension);\n        return OK;\n    }\n\n    /**\n    * @dev Provides a way to \"request\" (meant check if a token extension exists for a passed platform and if it doesn't then\n    * create a new one).\n    *\n    * @param _platform address of a platform for which token extension is requested\n    *\n    * @return result code of an operation.\n    */\n    function requestTokenExtension(address _platform) public returns (uint) {\n        address _tokenExtension = getTokenExtension(_platform);\n        if (_tokenExtension != 0x0) {\n            _emitTokenExtensionRequested(_platform, _tokenExtension);\n            return OK;\n        }\n\n        TokenExtensionsFactory _extensionsFactory = TokenExtensionsFactory(store.get(tokenExtensionFactory));\n        _tokenExtension = _extensionsFactory.createTokenExtension(_platform);\n        _setupTokenExtension(_platform, _tokenExtension);\n\n        _emitTokenExtensionRequested(_platform, _tokenExtension);\n        return OK;\n    }\n\n    /**\n    * @dev Gets an associated token extension address with provided platform. If no token extension was found\n    * then return 0x0.\n    *\n    * @param _platform platform address for associated token extension\n    *\n    * @return address of found token extension\n    */\n    function getTokenExtension(address _platform) public constant returns (address) {\n        return store.get(platformToExtension, _platform);\n    }\n\n    /**\n    * @dev Checks if a user has access rights and an owner of a token with provided symbol\n    *\n    * @param _symbol symbol associated with some token\n    * @param _user a user which should be tested for ownership\n    *\n    * @return `true` if a user is an owner, `false` otherwise\n    */\n    function isAssetOwner(bytes32 _symbol, address _user) public constant returns (bool) {\n        return AssetsManagerAggregations.isAssetOwner(store, platformToExtension, _symbol, getAssetBySymbol(_symbol), _user);\n    }\n\n    /**\n    * @dev Checks if a token with such symbol is registered in the system\n    *\n    * @param _symbol symbol associated with some token\n    *\n    * @return `true` if token with passed symbol exists, `false` otherwise\n    */\n    function isAssetSymbolExists(bytes32 _symbol) public constant returns (bool) {\n        return getAssetBySymbol(_symbol) != 0x0;\n    }\n\n    /**\n    * @dev Gets token's address which is associated with a symbol\n    *\n    * @param _symbol symbol associated with some token\n    *\n    * @return address of a token with passed symbol\n    */\n    function getAssetBySymbol(bytes32 _symbol) public constant returns (address) {\n        return ERC20ManagerInterface(lookupManager(\"ERC20Manager\")).getTokenAddressBySymbol(_symbol);\n    }\n\n    /**\n    * @dev STATISTICS.\n    * Returns all platforms where user is participating: has an asset in ownership or owning the whole platform.\n    *\n    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    *\n    * @param _user user\n    *\n    * @return _platforms list of platforms. Could contain repeated platforms so it is recommended to sift duplicates\n    */\n    function getParticipatingPlatformsForUser(address _user) public constant returns (address[] _platforms) {\n        PlatformsManagerInterface _platformsManager = PlatformsManagerInterface(lookupManager(\"PlatformsManager\"));\n        uint _partricipatedPlatformsCount = store.count(userToParticipatedPlatforms, bytes32(_user));\n        _platforms = new address[](_platformsManager.getPlatformsForUserCount(_user) + _partricipatedPlatformsCount);\n        uint _platformIdx;\n        for (_platformIdx = 0; _platformIdx < _partricipatedPlatformsCount; ++_platformIdx) {\n            _platforms[_platformIdx] = store.get(userToParticipatedPlatforms, bytes32(_user), _platformIdx);\n        }\n        for (uint _userPlatformIdx = 0; _platformIdx < _platforms.length; ++_platformIdx) {\n            _platforms[_platformIdx] = _platformsManager.getPlatformForUserAtIndex(_user, _userPlatformIdx++);\n        }\n    }\n\n    /**\n    * @dev Gets a number of assets in a platform where passed user is an owner.\n    *\n    * @param _platform hosting platform\n    * @param _owner user to be checked for ownership\n    *\n    * @return a number of assets in user's ownership\n    */\n    function getAssetsForOwnerCount(address _platform, address _owner) public constant returns (uint) {\n        return AssetsManagerAggregations.getAssetsForOwnerCount(getTokenExtension(_platform), _owner);\n    }\n\n    /**\n    * @dev Returns the exact asset symbol hosted in a platform with passed user as an owner by accessing it by index.\n    *\n    * @param _platform hosting platform\n    * @param _owner user to be checked for ownership\n    * @param _idx index of a symbol. Should no more than number of assets for this owner minus 1\n    *\n    * @return symbol of an asset\n    */\n    function getAssetForOwnerAtIndex(address _platform, address _owner, uint _idx) public constant returns (bytes32) {\n        return AssetsManagerAggregations.getAssetForOwnerAtIndex(getTokenExtension(_platform), _owner, _idx);\n    }\n\n    /**\n    * @dev STATISTICS.\n    * Returns number of assets that are in ownership by an owner regarding the whole system.\n    *\n    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    *\n    * @param _owner user to be checked for ownership\n    *\n    * @return number of assets\n    */\n    function getSystemAssetsForOwnerCount(address _owner) public constant returns (uint) {\n        return AssetsManagerAggregations.getSystemAssetsForOwnerCount(store, userToParticipatedPlatforms, userWithPlatformToOwnedSymbols, _owner);\n    }\n\n    /**\n    * @dev STATISTICS.\n    * Returns assets that are in ownership by an owner regarding the whole system.\n    *\n    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    *\n    * @param _owner user to be checked for ownership\n    *\n    * @return {\n    *   _tokens: list of tokens found in ownership of passed user\n    *   _tokenPlatforms: associated platforms where found tokens are hosted\n    *   _totalSupplies: associated total supplies for returned tokens\n    * }\n    */\n    function getSystemAssetsForOwner(address _owner) public constant returns (address[] _tokens, address[] _tokenPlatforms, uint[] _totalSupplies) {\n        uint _assetsCount = getSystemAssetsForOwnerCount(_owner);\n        _tokens = new address[](_assetsCount);\n        _tokenPlatforms = new address[](_assetsCount);\n        _totalSupplies = new uint[](_assetsCount);\n\n        bytes32 _ownerKey = bytes32(_owner);\n        uint _platformsCount = store.count(userToParticipatedPlatforms, _ownerKey);\n        uint _assetPointer;\n        address _platform;\n        bytes32 _symbolKey;\n        for (uint _platformIdx = 0; _platformIdx < _platformsCount; ++_platformIdx) {\n            _platform = store.get(userToParticipatedPlatforms, _ownerKey, _platformIdx);\n            ChronoBankPlatformInterface _chronoBankPlatform = ChronoBankPlatformInterface(_platform);\n            _symbolKey = keccak256(_owner, _platform);\n            uint _symbolsCount = store.count(userWithPlatformToOwnedSymbols, _symbolKey);\n            if (_symbolsCount != 0) {\n                _tokenPlatforms[_assetPointer] = _platform;\n            }\n            bytes32 _symbol;\n            for (uint _symbolIdx = 0; _symbolIdx < _symbolsCount; ++_symbolIdx) {\n                _symbol = store.get(userWithPlatformToOwnedSymbols, _symbolKey, _symbolIdx);\n                _tokens[_assetPointer] = _chronoBankPlatform.proxies(_symbol);\n                _totalSupplies[_assetPointer] = _chronoBankPlatform.totalSupply(_symbol);\n                _assetPointer += 1;\n            }\n        }\n    }\n\n    /**\n    * @dev STATISTICS.\n    * Returns list of owners (managers) that owns or has access rights to a token with passed symbolWithPlatformToUsers\n    *\n    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    *\n    * @param _symbol symbol associated with some token\n    *\n    * @return _managers list of owners\n    */\n    function getManagersForAssetSymbol(bytes32 _symbol) public constant returns (address[] _managers) {\n        address _token = getAssetBySymbol(_symbol);\n        address _platform = ChronoBankAssetProxyInterface(_token).chronoBankPlatform();\n        _managers = store.get(symbolWithPlatformToUsers, keccak256(_symbol, _platform));\n    }\n\n    /**\n    * @dev STATISTICS.\n    * Returns owners (managers) that has something in ownership inside user's ecosystem (in platforms that passed user owns).\n    *\n    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    *\n    * @param _owner user\n    *\n    * @return list of managers\n    */\n    function getManagers(address _owner) public constant returns (address[]) {\n        return AssetsManagerAggregations.getManagers(store, symbolWithPlatformToUsers, lookupManager(\"PlatformsManager\"), _owner);\n    }\n\n    /** Helper functions */\n\n    /**\n    * @dev Binds some internal variables during token extension setup.\n    * PRIVATE\n    */\n    function _setupTokenExtension(address _platform, address _tokenExtension) private {\n        assert(EventsHistory(getEventsHistory()).authorize(_tokenExtension));\n\n        store.add(tokenExtensions, _tokenExtension);\n        store.set(platformToExtension, _platform, _tokenExtension);\n    }\n\n    /** Events emitting */\n\n    function _emitError(uint _errorCode) private returns (uint) {\n        AssetsManagerEmitter(getEventsHistory()).emitError(_errorCode);\n        return _errorCode;\n    }\n\n    function _emitTokenExtensionRequested(address _platform, address _tokenExtension) private {\n        AssetsManagerEmitter(getEventsHistory()).emitTokenExtensionRequested(_platform, _tokenExtension);\n    }\n\n    function _emitTokenExtensionRegistered(address _platform, address _tokenExtension) private {\n        AssetsManagerEmitter(getEventsHistory()).emitTokenExtensionRegistered(_platform, _tokenExtension);\n    }\n\n    function _emitTokenExtensionUnregistered(address _tokenExtension) private {\n        AssetsManagerEmitter(getEventsHistory()).emitTokenExtensionUnregistered(_tokenExtension);\n    }\n}\n","abiDocs":[{"constant":true,"inputs":[{"name":"_platform","type":"address","description":"hosting platform"},{"name":"_owner","type":"address","description":"user to be checked for ownership"}],"name":"getAssetsForOwnerCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets a number of assets in a platform where passed user is an owner.","return":"a number of assets in user's ownership","signature":"getAssetsForOwnerCount(address,address)","signatureHash":"17db1071"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address","description":"contracts manager"},{"name":"_tokenExtensionFactory","type":"address","description":"token extension factory address"},{"name":"_tokenFactory","type":"address","description":"token and proxy factory address"}],"name":"init","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Initalizer. Used by contract owner to initialize and re-initialize contract after deploying new versions of related dependencies.","return":"result code of an operation. `OK` if all went well","signature":"init(address,address,address)","signatureHash":"184b9559"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"symbol associated with some token"},{"name":"_user","type":"address","description":"a user which should be tested for ownership"}],"name":"isAssetOwner","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","details":"Checks if a user has access rights and an owner of a token with provided symbol","return":"`true` if a user is an owner, `false` otherwise","signature":"isAssetOwner(bytes32,address)","signatureHash":"25742b46"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"token's associated symbol"},{"name":"_platform","type":"address","description":"address of a platform where asset's ownership had changed"},{"name":"_owner","type":"address","description":"user which was removed from the token's ownership"}],"name":"assetOwnerRemoved","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Implements AssetOwningListener interface to provide an ability to track asset ownership from chronobank platforms. Should be called when an existed owner of a symbol is removed in a platform. Allowed to be invoked only by AssetOwnershipResolver.    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES","signature":"assetOwnerRemoved(bytes32,address,address)","signatureHash":"26046743"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"symbol associated with some token"}],"name":"getAssetBySymbol","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets token's address which is associated with a symbol","return":"address of a token with passed symbol","signature":"getAssetBySymbol(bytes32)","signatureHash":"28aea08b"},{"constant":true,"inputs":[{"name":"_platform","type":"address","description":"hosting platform"},{"name":"_owner","type":"address","description":"user to be checked for ownership"},{"name":"_idx","type":"uint256","description":"index of a symbol. Should no more than number of assets for this owner minus 1"}],"name":"getAssetForOwnerAtIndex","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function","details":"Returns the exact asset symbol hosted in a platform with passed user as an owner by accessing it by index.","return":"symbol of an asset","signature":"getAssetForOwnerAtIndex(address,address,uint256)","signatureHash":"2cd060ce"},{"constant":false,"inputs":[{"name":"_tokenExtension","type":"address"}],"name":"emitTokenExtensionUnregistered","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitTokenExtensionUnregistered(address)","signatureHash":"2d305c82"},{"constant":false,"inputs":[{"name":"_tokenFactory","type":"address","description":"address of an updated token and proxy factory contract"}],"name":"setTokenFactory","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Sets a new address of token and proxy factory contract as currently used in AssetsManager","return":"result code of an operation. `OK` if all went well","signature":"setTokenFactory(address)","signatureHash":"2f73a9f8"},{"constant":true,"inputs":[{"name":"_owner","type":"address","description":"user"}],"name":"getManagers","outputs":[{"name":"","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function","details":"STATISTICS. Returns owners (managers) that has something in ownership inside user's ecosystem (in platforms that passed user owns).    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES","return":"list of managers","signature":"getManagers(address)","signatureHash":"33060226"},{"constant":true,"inputs":[],"name":"getTokenExtensionFactory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets an address of currenty used token extension factory","return":"address of a factory","signature":"getTokenExtensionFactory()","signatureHash":"44ef3ea5"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Finalize ownership pass.     * Can only be called by pending owner.","signature":"claimContractOwnership()","signatureHash":"4592cd1d"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32","description":"is a manager's identifier. 0x0 is not allowed."}],"name":"lookupManager","payable":false,"stateMutability":"view","type":"function","details":"Returns manager's address by its identifier (type).","notice":"Will crash if no manager in the system with given identifier.","signature":"lookupManager(bytes32)","signatureHash":"4fe59012"},{"constant":true,"inputs":[],"name":"contractsManager","payable":false,"stateMutability":"view","type":"function","signature":"contractsManager()","signatureHash":"53253d31"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"address of the next owner. 0x0 is not allowed."}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Prepares ownership pass.     * Can only be called by current owner.","signature":"changeContractOwnership(address)","signatureHash":"557f4bc9"},{"constant":true,"inputs":[{"name":"_owner","type":"address","description":"user to be checked for ownership"}],"name":"getSystemAssetsForOwnerCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","details":"STATISTICS. Returns number of assets that are in ownership by an owner regarding the whole system.    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES","return":"number of assets","signature":"getSystemAssetsForOwnerCount(address)","signatureHash":"55e06a74"},{"constant":true,"inputs":[],"name":"pendingContractOwner","payable":false,"stateMutability":"view","type":"function","signature":"pendingContractOwner()","signatureHash":"5aa77d3c"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"setEventsHistory(address)","signatureHash":"6521afd7"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"token's associated symbol"},{"name":"_platform","type":"address","description":"address of a platform where asset's ownership had changed"},{"name":"_owner","type":"address","description":"user which was added as an owner of the token"}],"name":"assetOwnerAdded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Implements AssetOwningListener interface to provide an ability to track asset ownership from chronobank platforms. Should be called when new owner of a symbol is added in a platform. Allowed to be invoked only by AssetOwnershipResolver.    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES","signature":"assetOwnerAdded(bytes32,address,address)","signatureHash":"660a333e"},{"constant":true,"inputs":[{"name":"_owner","type":"address","description":"user to be checked for ownership"}],"name":"getSystemAssetsForOwner","outputs":[{"name":"_tokens","type":"address[]"},{"name":"_tokenPlatforms","type":"address[]"},{"name":"_totalSupplies","type":"uint256[]"}],"payable":false,"stateMutability":"view","type":"function","details":"STATISTICS. Returns assets that are in ownership by an owner regarding the whole system.    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES","return":"{  _tokens: list of tokens found in ownership of passed user  _tokenPlatforms: associated platforms where found tokens are hosted  _totalSupplies: associated total supplies for returned tokens }","signature":"getSystemAssetsForOwner(address)","signatureHash":"68bf8b90"},{"constant":true,"inputs":[{"name":"_tokenExtension","type":"address","description":"address of a token extension"}],"name":"containsTokenExtension","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","details":"Checks if a provided token extension address is a part of the system","return":"`true` if a token extension is inside AssetsManager, `false` otherwise","signature":"containsTokenExtension(address)","signatureHash":"6bc8acf5"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address","description":"contracts manager. 0x0 is not allowed."}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Setter for ContractsManager. Force overrides currect manager.","signature":"setContractsManager(address)","signatureHash":"71d3b573"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"destroy()","signatureHash":"83197ef0"},{"constant":false,"inputs":[{"name":"_tokenExtension","type":"address","description":"address of token extension"}],"name":"registerTokenExtension","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Registers and stores token extension of a platform into the system. Mostly this method should be used when platform's token extention was removed manually from AssetsManager or there was no token extension at all. It is preferred to create token extension by calling requestTokenExtension: this will ensure that the latest version of token extension contract will be used. There might be ONLY ONE token extension at a time associated with a platform and be registered in the system. Can be used only by platform's owner associated with this token extension.","return":"result code of an operation. ERROR_ASSETS_MANAGER_EXTENSION_ALREADY_EXISTS, ERROR_ASSETS_MANAGER_EXTENSION_ALREADY_EXISTS          might be returned.","signature":"registerTokenExtension(address)","signatureHash":"89c165d0"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_tokenExtension","type":"address"}],"name":"emitTokenExtensionRegistered","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitTokenExtensionRegistered(address,address)","signatureHash":"8f8068bb"},{"constant":true,"inputs":[],"name":"getTokenFactory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets an address of currenty used token and proxy factory","return":"address of a factory","signature":"getTokenFactory()","signatureHash":"925d6ba2"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_tokenExtension","type":"address"}],"name":"emitTokenExtensionRequested","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitTokenExtensionRequested(address,address)","signatureHash":"9e6c2765"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"the next contract owner"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Direct ownership pass without change/claim pattern. Can be invoked only by current contract owner","return":"`true` if success, `false` otherwise","signature":"transferContractOwnership(address)","signatureHash":"a843c51f"},{"constant":false,"inputs":[{"name":"_tokenExtensionFactory","type":"address","description":"address of an updated token extension factory contract"}],"name":"setTokenExtensionFactory","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Sets a new address of token extension factory contract as currently used in AssetsManager","return":"result code of an operation. `OK` if all went well","signature":"setTokenExtensionFactory(address)","signatureHash":"b5fb8421"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"symbol associated with some token"}],"name":"getManagersForAssetSymbol","outputs":[{"name":"_managers","type":"address[]","description":"list of owners"}],"payable":false,"stateMutability":"view","type":"function","details":"STATISTICS. Returns list of owners (managers) that owns or has access rights to a token with passed symbolWithPlatformToUsers    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES","return":"_managers list of owners","signature":"getManagersForAssetSymbol(bytes32)","signatureHash":"bb908ff0"},{"constant":false,"inputs":[{"name":"_platform","type":"address","description":"address of a platform for which token extension is requested"}],"name":"requestTokenExtension","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Provides a way to \"request\" (meant check if a token extension exists for a passed platform and if it doesn't then create a new one).","return":"result code of an operation.","signature":"requestTokenExtension(address)","signatureHash":"c97f5787"},{"constant":true,"inputs":[],"name":"contractOwner","payable":false,"stateMutability":"view","type":"function","signature":"contractOwner()","signatureHash":"ce606ee0"},{"constant":true,"inputs":[{"name":"_user","type":"address","description":"user"}],"name":"getParticipatingPlatformsForUser","outputs":[{"name":"_platforms","type":"address[]","description":"list of platforms. Could contain repeated platforms so it is recommended to sift duplicates"}],"payable":false,"stateMutability":"view","type":"function","details":"STATISTICS. Returns all platforms where user is participating: has an asset in ownership or owning the whole platform.    * DEPRECATED. WILL BE REMOVED IN NEXT RELEASES","return":"_platforms list of platforms. Could contain repeated platforms so it is recommended to sift duplicates","signature":"getParticipatingPlatformsForUser(address)","signatureHash":"d2920d42"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"symbol associated with some token"}],"name":"isAssetSymbolExists","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","details":"Checks if a token with such symbol is registered in the system","return":"`true` if token with passed symbol exists, `false` otherwise","signature":"isAssetSymbolExists(bytes32)","signatureHash":"d5ed0d17"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","payable":false,"stateMutability":"nonpayable","type":"function","signature":"withdrawnTokens(address[],address)","signatureHash":"d8f9659b"},{"constant":false,"inputs":[{"name":"_tokenExtension","type":"address","description":"address of a token extension"}],"name":"unregisterTokenExtension","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Unregisters and removes token extension from the system. It should be used when you know what are you doing, because it will remove record of token extension for a platform and to continue using an associated token extension with platform you should register a new token extension address or request a brand new one (see `requestTokenExtension` method). Can be used only by platform's owner associated with this token extension.","return":"result code of an operation. ERROR_ASSETS_MANAGER_INVALID_INVOCATION might be returned.","signature":"unregisterTokenExtension(address)","signatureHash":"db06471f"},{"constant":false,"inputs":[{"name":"errorCode","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","notice":"Emitting events ","signature":"emitError(uint256)","signatureHash":"df26ca08"},{"constant":true,"inputs":[{"name":"_platform","type":"address","description":"platform address for associated token extension"}],"name":"getTokenExtension","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets an associated token extension address with provided platform. If no token extension was found then return 0x0.","return":"address of found token extension","signature":"getTokenExtension(address)","signatureHash":"e5ebb7a5"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","payable":false,"stateMutability":"view","type":"function","signature":"isAuthorized(address)","signatureHash":"fe9fbb80"},{"constant":true,"inputs":[],"name":"getEventsHistory","payable":false,"stateMutability":"view","type":"function","signature":"getEventsHistory()","signatureHash":"fff10aba"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event","signature":"Error(address,uint256)","signatureHash":"9cf38cf2"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":false,"name":"tokenExtension","type":"address"}],"name":"TokenExtensionRequested","type":"event","signature":"TokenExtensionRequested(address,address,address)","signatureHash":"f149a753"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":false,"name":"tokenExtension","type":"address"}],"name":"TokenExtensionRegistered","type":"event","signature":"TokenExtensionRegistered(address,address,address)","signatureHash":"adaec20b"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"tokenExtension","type":"address"}],"name":"TokenExtensionUnregistered","type":"event","signature":"TokenExtensionUnregistered(address,address)","signatureHash":"3f50f7da"}]}
