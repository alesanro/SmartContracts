{"title":"ChronoBank Platform. * The official ChronoBank assets platform powering TIME and LHT tokens, and possibly other unknown tokens needed later. Platform uses MultiEventsHistory contract to keep events, so that in case it needs to be redeployed at some point, all the events keep appearing at the same place. * Every asset is meant to be used through a proxy contract. Only one proxy contract have access rights for a particular asset. * Features: transfers, allowances, supply adjustments, lost wallet access recovery. * Note: all the non constant functions return false instead of throwing in case if state change didn't happen yet.","fileName":"/contracts/core/platform/ChronoBankPlatform.sol","name":"ChronoBankPlatform","abi":[{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setupEventsHistory","outputs":[{"name":"errorCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_partowner","type":"address"}],"name":"addAssetPartOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"},{"name":"_name","type":"string"},{"name":"_description","type":"string"},{"name":"_baseUnit","type":"uint8"},{"name":"_isReissuable","type":"bool"}],"name":"issueAsset","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_holder","type":"address"}],"name":"getHolderId","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_partowner","type":"address"}],"name":"removePartOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"},{"name":"_symbol","type":"bytes32"},{"name":"_sender","type":"address"}],"name":"proxyApprove","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"},{"name":"_symbol","type":"bytes32"},{"name":"_reference","type":"string"},{"name":"_sender","type":"address"}],"name":"proxyTransferFromWithReference","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_from","type":"address"},{"name":"_spender","type":"address"},{"name":"_symbol","type":"bytes32"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"holders","outputs":[{"name":"addr","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"isCreated","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"trust","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_holder","type":"address"},{"name":"_symbol","type":"bytes32"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"},{"name":"_reference","type":"string"}],"name":"emitTransfer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_eventsAdmin","type":"address"}],"name":"setupEventsAdmin","outputs":[{"name":"errorCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"},{"name":"_symbol","type":"bytes32"},{"name":"_reference","type":"string"},{"name":"_sender","type":"address"}],"name":"proxyTransferWithReference","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"pendingContractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_holderId","type":"uint256"},{"name":"_symbol","type":"bytes32"}],"name":"_balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_proxyAddress","type":"address"},{"name":"_symbol","type":"bytes32"}],"name":"setProxy","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"}],"name":"recover","outputs":[{"name":"errorCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"}],"name":"isTrusted","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_holderId","type":"uint256"}],"name":"_address","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"bytes32"}],"name":"proxies","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"holdersCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_listener","type":"address"}],"name":"setupAssetOwningListener","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"bytes32"}],"name":"assets","outputs":[{"name":"owner","type":"uint256"},{"name":"totalSupply","type":"uint256"},{"name":"name","type":"string"},{"name":"description","type":"string"},{"name":"isReissuable","type":"bool"},{"name":"baseUnit","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"},{"name":"_name","type":"string"},{"name":"_description","type":"string"},{"name":"_baseUnit","type":"uint8"},{"name":"_isReissuable","type":"bool"},{"name":"_account","type":"address"}],"name":"issueAsset","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_partowner","type":"address"}],"name":"addPartOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_symbol","type":"bytes32"}],"name":"emitOwnershipChange","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"},{"name":"_by","type":"address"}],"name":"emitIssue","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"description","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"isReissuable","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"},{"name":"_by","type":"address"}],"name":"emitRevoke","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"}],"name":"revokeAsset","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"partowners","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_symbol","type":"bytes32"}],"name":"hasAssetRights","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"symbols","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"contractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_spender","type":"address"},{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"}],"name":"emitApprove","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"eventsAdmin","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"baseUnit","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_errorCode","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"}],"name":"reissueAsset","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_symbol","type":"bytes32"}],"name":"isOwner","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_by","type":"address"}],"name":"emitRecovery","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_partowner","type":"address"}],"name":"removeAssetPartOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbolsCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"eventsHistory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"distrust","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_newOwner","type":"address"}],"name":"changeOwnership","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":true,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"reference","type":"string"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":true,"name":"by","type":"address"}],"name":"Issue","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":true,"name":"by","type":"address"}],"name":"Revoke","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":true,"name":"symbol","type":"bytes32"}],"name":"OwnershipChange","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":true,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approve","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"by","type":"address"}],"name":"Recovery","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event"}],"source":"pragma solidity ^0.4.11;\n\nimport \"../common/Object.sol\";\nimport \"./ChronoBankPlatformEmitter.sol\";\nimport \"../lib/SafeMath.sol\";\n\ncontract ProxyEventsEmitter {\n    function emitTransfer(address _from, address _to, uint _value);\n    function emitApprove(address _from, address _spender, uint _value);\n}\n\n\ncontract AssetOwningListener {\n    function assetOwnerAdded(bytes32 _symbol, address _platform, address _owner);\n    function assetOwnerRemoved(bytes32 _symbol, address _platform, address _owner);\n}\n\n/**\n * @title ChronoBank Platform.\n *\n * The official ChronoBank assets platform powering TIME and LHT tokens, and possibly\n * other unknown tokens needed later.\n * Platform uses MultiEventsHistory contract to keep events, so that in case it needs to be redeployed\n * at some point, all the events keep appearing at the same place.\n *\n * Every asset is meant to be used through a proxy contract. Only one proxy contract have access\n * rights for a particular asset.\n *\n * Features: transfers, allowances, supply adjustments, lost wallet access recovery.\n *\n * Note: all the non constant functions return false instead of throwing in case if state change\n * didn't happen yet.\n */\ncontract ChronoBankPlatform is Object, ChronoBankPlatformEmitter {\n    using SafeMath for uint;\n\n    uint constant CHRONOBANK_PLATFORM_SCOPE = 15000;\n    uint constant CHRONOBANK_PLATFORM_PROXY_ALREADY_EXISTS = CHRONOBANK_PLATFORM_SCOPE + 0;\n    uint constant CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF = CHRONOBANK_PLATFORM_SCOPE + 1;\n    uint constant CHRONOBANK_PLATFORM_INVALID_VALUE = CHRONOBANK_PLATFORM_SCOPE + 2;\n    uint constant CHRONOBANK_PLATFORM_INSUFFICIENT_BALANCE = CHRONOBANK_PLATFORM_SCOPE + 3;\n    uint constant CHRONOBANK_PLATFORM_NOT_ENOUGH_ALLOWANCE = CHRONOBANK_PLATFORM_SCOPE + 4;\n    uint constant CHRONOBANK_PLATFORM_ASSET_ALREADY_ISSUED = CHRONOBANK_PLATFORM_SCOPE + 5;\n    uint constant CHRONOBANK_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE = CHRONOBANK_PLATFORM_SCOPE + 6;\n    uint constant CHRONOBANK_PLATFORM_CANNOT_REISSUE_FIXED_ASSET = CHRONOBANK_PLATFORM_SCOPE + 7;\n    uint constant CHRONOBANK_PLATFORM_SUPPLY_OVERFLOW = CHRONOBANK_PLATFORM_SCOPE + 8;\n    uint constant CHRONOBANK_PLATFORM_NOT_ENOUGH_TOKENS = CHRONOBANK_PLATFORM_SCOPE + 9;\n    uint constant CHRONOBANK_PLATFORM_INVALID_NEW_OWNER = CHRONOBANK_PLATFORM_SCOPE + 10;\n    uint constant CHRONOBANK_PLATFORM_ALREADY_TRUSTED = CHRONOBANK_PLATFORM_SCOPE + 11;\n    uint constant CHRONOBANK_PLATFORM_SHOULD_RECOVER_TO_NEW_ADDRESS = CHRONOBANK_PLATFORM_SCOPE + 12;\n    uint constant CHRONOBANK_PLATFORM_ASSET_IS_NOT_ISSUED = CHRONOBANK_PLATFORM_SCOPE + 13;\n    uint constant CHRONOBANK_PLATFORM_INVALID_INVOCATION = CHRONOBANK_PLATFORM_SCOPE + 17;\n\n    // Structure of a particular asset.\n    struct Asset {\n        uint owner;                       // Asset's owner id.\n        uint totalSupply;                 // Asset's total supply.\n        string name;                      // Asset's name, for information purposes.\n        string description;               // Asset's description, for information purposes.\n        bool isReissuable;                // Indicates if asset have dynamic or fixed supply.\n        uint8 baseUnit;                   // Proposed number of decimals.\n        mapping(uint => Wallet) wallets;  // Holders wallets.\n        mapping(uint => bool) partowners; // Part-owners of an asset; have less access rights than owner\n    }\n\n    // Structure of an asset holder wallet for particular asset.\n    struct Wallet {\n        uint balance;\n        mapping(uint => uint) allowance;\n    }\n\n    // Structure of an asset holder.\n    struct Holder {\n        address addr;                    // Current address of the holder.\n        mapping(address => bool) trust;  // Addresses that are trusted with recovery proocedure.\n    }\n\n    // Iterable mapping pattern is used for holders.\n    uint public holdersCount;\n    mapping(uint => Holder) public holders;\n\n    // This is an access address mapping. Many addresses may have access to a single holder.\n    mapping(address => uint) holderIndex;\n\n    // List of symbols that exist in a platform\n    bytes32[] public symbols;\n\n    // Asset symbol to asset mapping.\n    mapping(bytes32 => Asset) public assets;\n\n    // Asset symbol to asset proxy mapping.\n    mapping(bytes32 => address) public proxies;\n\n    /** Co-owners of a platform. Has less access rights than a root contract owner */\n    mapping(address => bool) public partowners;\n\n    // Should use interface of the emitter, but address of events history.\n    address public eventsHistory;\n    address public eventsAdmin;\n\n    address owningListener;\n\n    /**\n     * Emits Error event with specified error message.\n     *\n     * Should only be used if no state changes happened.\n     *\n     * @param _errorCode code of an error\n     */\n    function _error(uint _errorCode) internal returns(uint) {\n        ChronoBankPlatformEmitter(eventsHistory).emitError(_errorCode);\n        return _errorCode;\n    }\n\n    /**\n     * Emits Error if called not by asset owner.\n     */\n    modifier onlyOwner(bytes32 _symbol) {\n        if (isOwner(msg.sender, _symbol)) {\n            _;\n        }\n    }\n\n    /**\n     * Emits Error if called not by asset owner.\n     */\n    modifier onlyEventsAdmin() {\n        if (eventsAdmin == msg.sender || contractOwner == msg.sender) {\n            _;\n        }\n    }\n\n    /**\n    * @dev UNAUTHORIZED if called not by one of symbol's partowners or owner\n    */\n    modifier onlyOneOfOwners(bytes32 _symbol) {\n        if (hasAssetRights(msg.sender, _symbol)) {\n            _;\n        }\n    }\n\n    /**\n    * @dev UNAUTHORIZED if called not by one of partowners or contract's owner\n    */\n    modifier onlyOneOfContractOwners() {\n        if (contractOwner == msg.sender || partowners[msg.sender]) {\n            _;\n        }\n    }\n\n    /**\n     * Emits Error if called not by asset proxy.\n     */\n    modifier onlyProxy(bytes32 _symbol) {\n        if (proxies[_symbol] == msg.sender) {\n            _;\n        }\n    }\n\n    /**\n     * Emits Error if _from doesn't trust _to.\n     */\n    modifier checkTrust(address _from, address _to) {\n        if (isTrusted(_from, _to)) {\n            _;\n        }\n    }\n\n    /**\n    * Adds a co-owner of a contract. Might be more than one co-owner\n    * @dev Allowed to only contract onwer\n    *\n    * @param _partowner a co-owner of a contract\n    *\n    * @return result code of an operation\n    */\n    function addPartOwner(address _partowner) onlyContractOwner returns (uint) {\n        partowners[_partowner] = true;\n        return OK;\n    }\n\n    /**\n    * Removes a co-owner of a contract\n    * @dev Should be performed only by root contract owner\n    *\n    * @param _partowner a co-owner of a contract\n    *\n    * @return result code of an operation\n    */\n    function removePartOwner(address _partowner) onlyContractOwner returns (uint) {\n        delete partowners[_partowner];\n        return OK;\n    }\n\n    /**\n     * Sets EventsHstory contract address.\n     *\n     * Can be set only by events history admon or owner.\n     *\n     * @param _eventsHistory MultiEventsHistory contract address.\n     *\n     * @return success.\n     */\n    function setupEventsHistory(address _eventsHistory) onlyEventsAdmin returns (uint errorCode) {\n        eventsHistory = _eventsHistory;\n        return OK;\n    }\n\n    /**\n     * Sets EventsHstory contract admin address.\n     *\n     * Can be set only by contract owner.\n     *\n     * @param _eventsAdmin admin contract address.\n     *\n     * @return success.\n     */\n    function setupEventsAdmin(address _eventsAdmin) onlyContractOwner returns (uint errorCode) {\n        eventsAdmin = _eventsAdmin;\n        return OK;\n    }\n\n    /**\n    * @dev DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    */\n    function setupAssetOwningListener(address _listener) onlyEventsAdmin public returns (uint) {\n        owningListener = _listener;\n        return OK;\n    }\n\n    /**\n    * Provides a cheap way to get number of symbols registered in a platform\n    *\n    * @return number of symbols\n    */\n    function symbolsCount() public constant returns (uint) {\n        return symbols.length;\n    }\n\n    /**\n     * Check asset existance.\n     *\n     * @param _symbol asset symbol.\n     *\n     * @return asset existance.\n     */\n    function isCreated(bytes32 _symbol) constant returns(bool) {\n        return assets[_symbol].owner != 0;\n    }\n\n    /**\n     * Returns asset decimals.\n     *\n     * @param _symbol asset symbol.\n     *\n     * @return asset decimals.\n     */\n    function baseUnit(bytes32 _symbol) constant returns(uint8) {\n        return assets[_symbol].baseUnit;\n    }\n\n    /**\n     * Returns asset name.\n     *\n     * @param _symbol asset symbol.\n     *\n     * @return asset name.\n     */\n    function name(bytes32 _symbol) constant returns(string) {\n        return assets[_symbol].name;\n    }\n\n    /**\n     * Returns asset description.\n     *\n     * @param _symbol asset symbol.\n     *\n     * @return asset description.\n     */\n    function description(bytes32 _symbol) constant returns(string) {\n        return assets[_symbol].description;\n    }\n\n    /**\n     * Returns asset reissuability.\n     *\n     * @param _symbol asset symbol.\n     *\n     * @return asset reissuability.\n     */\n    function isReissuable(bytes32 _symbol) constant returns(bool) {\n        return assets[_symbol].isReissuable;\n    }\n\n    /**\n     * Returns asset owner address.\n     *\n     * @param _symbol asset symbol.\n     *\n     * @return asset owner address.\n     */\n    function owner(bytes32 _symbol) constant returns(address) {\n        return holders[assets[_symbol].owner].addr;\n    }\n\n    /**\n     * Check if specified address has asset owner rights.\n     *\n     * @param _owner address to check.\n     * @param _symbol asset symbol.\n     *\n     * @return owner rights availability.\n     */\n    function isOwner(address _owner, bytes32 _symbol) constant returns(bool) {\n        return isCreated(_symbol) && (assets[_symbol].owner == getHolderId(_owner));\n    }\n\n    /**\n    * Checks if a specified address has asset owner or co-owner rights.\n    *\n    * @param _owner address to check.\n    * @param _symbol asset symbol.\n    *\n    * @return owner rights availability.\n    */\n    function hasAssetRights(address _owner, bytes32 _symbol) constant returns (bool) {\n        uint holderId = getHolderId(_owner);\n        return isCreated(_symbol) && (assets[_symbol].owner == holderId || assets[_symbol].partowners[holderId]);\n    }\n\n    /**\n     * Returns asset total supply.\n     *\n     * @param _symbol asset symbol.\n     *\n     * @return asset total supply.\n     */\n    function totalSupply(bytes32 _symbol) constant returns(uint) {\n        return assets[_symbol].totalSupply;\n    }\n\n    /**\n     * Returns asset balance for a particular holder.\n     *\n     * @param _holder holder address.\n     * @param _symbol asset symbol.\n     *\n     * @return holder balance.\n     */\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint) {\n        return _balanceOf(getHolderId(_holder), _symbol);\n    }\n\n    /**\n     * Returns asset balance for a particular holder id.\n     *\n     * @param _holderId holder id.\n     * @param _symbol asset symbol.\n     *\n     * @return holder balance.\n     */\n    function _balanceOf(uint _holderId, bytes32 _symbol) constant returns(uint) {\n        return assets[_symbol].wallets[_holderId].balance;\n    }\n\n    /**\n     * Returns current address for a particular holder id.\n     *\n     * @param _holderId holder id.\n     *\n     * @return holder address.\n     */\n    function _address(uint _holderId) constant returns(address) {\n        return holders[_holderId].addr;\n    }\n\n    /**\n    * Adds a co-owner for an asset with provided symbol.\n    * @dev Should be performed by a contract owner or its co-owners\n    *\n    * @param _symbol asset's symbol\n    * @param _partowner a co-owner of an asset\n    *\n    * @return errorCode result code of an operation\n    */\n    function addAssetPartOwner(bytes32 _symbol, address _partowner) onlyOneOfOwners(_symbol) public returns (uint) {\n        uint holderId = _createHolderId(_partowner);\n        assets[_symbol].partowners[holderId] = true;\n        _delegateAssetOwnerAdded(_symbol, _partowner);\n        ChronoBankPlatformEmitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);\n        return OK;\n    }\n\n    /**\n    * Removes a co-owner for an asset with provided symbol.\n    * @dev Should be performed by a contract owner or its co-owners\n    *\n    * @param _symbol asset's symbol\n    * @param _partowner a co-owner of an asset\n    *\n    * @return errorCode result code of an operation\n    */\n    function removeAssetPartOwner(bytes32 _symbol, address _partowner) onlyOneOfOwners(_symbol) public returns (uint) {\n        uint holderId = getHolderId(_partowner);\n        delete assets[_symbol].partowners[holderId];\n        _delegateAssetOwnerRemoved(_symbol, _partowner);\n        ChronoBankPlatformEmitter(eventsHistory).emitOwnershipChange(_partowner, 0x0, _symbol);\n        return OK;\n    }\n\n    /**\n     * Sets Proxy contract address for a particular asset.\n     *\n     * Can be set only once for each asset, and only by contract owner.\n     *\n     * @param _proxyAddress Proxy contract address.\n     * @param _symbol asset symbol.\n     *\n     * @return success.\n     */\n    function setProxy(address _proxyAddress, bytes32 _symbol) onlyOneOfContractOwners returns(uint) {\n        if (proxies[_symbol] != 0x0) {\n            return CHRONOBANK_PLATFORM_PROXY_ALREADY_EXISTS;\n        }\n\n        proxies[_symbol] = _proxyAddress;\n        return OK;\n    }\n\n    /**\n     * Transfers asset balance between holders wallets.\n     *\n     * @param _fromId holder id to take from.\n     * @param _toId holder id to give to.\n     * @param _value amount to transfer.\n     * @param _symbol asset symbol.\n     */\n    function _transferDirect(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal {\n        assets[_symbol].wallets[_fromId].balance = assets[_symbol].wallets[_fromId].balance.sub(_value);\n        assets[_symbol].wallets[_toId].balance = assets[_symbol].wallets[_toId].balance.add(_value);\n    }\n\n    /**\n     * Transfers asset balance between holders wallets.\n     *\n     * Performs sanity checks and takes care of allowances adjustment.\n     *\n     * @param _fromId holder id to take from.\n     * @param _toId holder id to give to.\n     * @param _value amount to transfer.\n     * @param _symbol asset symbol.\n     * @param _reference transfer comment to be included in a Transfer event.\n     * @param _senderId transfer initiator holder id.\n     *\n     * @return success.\n     */\n    function _transfer(uint _fromId, uint _toId, uint _value, bytes32 _symbol, string _reference, uint _senderId) internal returns(uint) {\n        // Should not allow to send to oneself.\n        if (_fromId == _toId) {\n            return _error(CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n        }\n        // Should have positive value.\n        if (_value == 0) {\n            return _error(CHRONOBANK_PLATFORM_INVALID_VALUE);\n        }\n        // Should have enough balance.\n        if (_balanceOf(_fromId, _symbol) < _value) {\n            return _error(CHRONOBANK_PLATFORM_INSUFFICIENT_BALANCE);\n        }\n        // Should have enough allowance.\n        if (_fromId != _senderId && _allowance(_fromId, _senderId, _symbol) < _value) {\n            return _error(CHRONOBANK_PLATFORM_NOT_ENOUGH_ALLOWANCE);\n        }\n\n        _transferDirect(_fromId, _toId, _value, _symbol);\n        // Adjust allowance.\n        if (_fromId != _senderId) {\n            assets[_symbol].wallets[_fromId].allowance[_senderId] = assets[_symbol].wallets[_fromId].allowance[_senderId].sub(_value);\n        }\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: n/a after HF 4;\n        // Recursive Call: safe, all changes already made.\n        ChronoBankPlatformEmitter(eventsHistory).emitTransfer(_address(_fromId), _address(_toId), _symbol, _value, _reference);\n        _proxyTransferEvent(_fromId, _toId, _value, _symbol);\n        return OK;\n    }\n\n    /**\n     * Transfers asset balance between holders wallets.\n     *\n     * Can only be called by asset proxy.\n     *\n     * @param _to holder address to give to.\n     * @param _value amount to transfer.\n     * @param _symbol asset symbol.\n     * @param _reference transfer comment to be included in a Transfer event.\n     * @param _sender transfer initiator address.\n     *\n     * @return success.\n     */\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) onlyProxy(_symbol) returns(uint) {\n        return _transfer(getHolderId(_sender), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));\n    }\n\n    /**\n     * Ask asset Proxy contract to emit ERC20 compliant Transfer event.\n     *\n     * @param _fromId holder id to take from.\n     * @param _toId holder id to give to.\n     * @param _value amount to transfer.\n     * @param _symbol asset symbol.\n     */\n    function _proxyTransferEvent(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal {\n        if (proxies[_symbol] != 0x0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: n/a after HF 4;\n            // Recursive Call: safe, all changes already made.\n            ProxyEventsEmitter(proxies[_symbol]).emitTransfer(_address(_fromId), _address(_toId), _value);\n        }\n    }\n\n    /**\n     * Returns holder id for the specified address.\n     *\n     * @param _holder holder address.\n     *\n     * @return holder id.\n     */\n    function getHolderId(address _holder) constant returns(uint) {\n        return holderIndex[_holder];\n    }\n\n    /**\n     * Returns holder id for the specified address, creates it if needed.\n     *\n     * @param _holder holder address.\n     *\n     * @return holder id.\n     */\n    function _createHolderId(address _holder) internal returns(uint) {\n        uint holderId = holderIndex[_holder];\n        if (holderId == 0) {\n            holderId = ++holdersCount;\n            holders[holderId].addr = _holder;\n            holderIndex[_holder] = holderId;\n        }\n        return holderId;\n    }\n\n    /**\n     * Issues new asset token on the platform.\n     *\n     * Tokens issued with this call go straight to contract owner.\n     * Each symbol can be issued only once, and only by contract owner.\n     *\n     * @param _symbol asset symbol.\n     * @param _value amount of tokens to issue immediately.\n     * @param _name name of the asset.\n     * @param _description description for the asset.\n     * @param _baseUnit number of decimals.\n     * @param _isReissuable dynamic or fixed supply.\n     *\n     * @return success.\n     */\n    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns(uint) {\n        return issueAsset(_symbol, _value, _name, _description, _baseUnit, _isReissuable, msg.sender);\n    }\n\n    /**\n     * Issues new asset token on the platform.\n     *\n     * Tokens issued with this call go straight to contract owner.\n     * Each symbol can be issued only once, and only by contract owner.\n     *\n     * @param _symbol asset symbol.\n     * @param _value amount of tokens to issue immediately.\n     * @param _name name of the asset.\n     * @param _description description for the asset.\n     * @param _baseUnit number of decimals.\n     * @param _isReissuable dynamic or fixed supply.\n     * @param _account address where issued balance will be held\n     *\n     * @return success.\n     */\n    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable, address _account) onlyOneOfContractOwners public returns(uint) {\n        // Should have positive value if supply is going to be fixed.\n        if (_value == 0 && !_isReissuable) {\n            return _error(CHRONOBANK_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE);\n        }\n        // Should not be issued yet.\n        if (isCreated(_symbol)) {\n            return _error(CHRONOBANK_PLATFORM_ASSET_ALREADY_ISSUED);\n        }\n        uint holderId = _createHolderId(_account);\n        uint creatorId = _account == msg.sender ? holderId : _createHolderId(msg.sender);\n\n        symbols.push(_symbol);\n        assets[_symbol] = Asset(creatorId, _value, _name, _description, _isReissuable, _baseUnit);\n        assets[_symbol].wallets[holderId].balance = _value;\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: n/a after HF 4;\n        // Recursive Call: safe, all changes already made.\n        _delegateAssetOwnerAdded(_symbol, _address(creatorId));\n        ChronoBankPlatformEmitter(eventsHistory).emitIssue(_symbol, _value, _address(holderId));\n        return OK;\n    }\n\n    /**\n     * Issues additional asset tokens if the asset have dynamic supply.\n     *\n     * Tokens issued with this call go straight to asset owner.\n     * Can only be called by asset owner.\n     *\n     * @param _symbol asset symbol.\n     * @param _value amount of additional tokens to issue.\n     *\n     * @return success.\n     */\n    function reissueAsset(bytes32 _symbol, uint _value) onlyOneOfOwners(_symbol) public returns(uint) {\n        // Should have positive value.\n        if (_value == 0) {\n            return _error(CHRONOBANK_PLATFORM_INVALID_VALUE);\n        }\n        Asset storage asset = assets[_symbol];\n        // Should have dynamic supply.\n        if (!asset.isReissuable) {\n            return _error(CHRONOBANK_PLATFORM_CANNOT_REISSUE_FIXED_ASSET);\n        }\n        // Resulting total supply should not overflow.\n        if (asset.totalSupply + _value < asset.totalSupply) {\n            return _error(CHRONOBANK_PLATFORM_SUPPLY_OVERFLOW);\n        }\n        uint holderId = getHolderId(msg.sender);\n        asset.wallets[holderId].balance = asset.wallets[holderId].balance.add(_value);\n        asset.totalSupply = asset.totalSupply.add(_value);\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: n/a after HF 4;\n        // Recursive Call: safe, all changes already made.\n        ChronoBankPlatformEmitter(eventsHistory).emitIssue(_symbol, _value, _address(holderId));\n        _proxyTransferEvent(0, holderId, _value, _symbol);\n        return OK;\n    }\n\n    /**\n     * Destroys specified amount of senders asset tokens.\n     *\n     * @param _symbol asset symbol.\n     * @param _value amount of tokens to destroy.\n     *\n     * @return success.\n     */\n    function revokeAsset(bytes32 _symbol, uint _value) public returns(uint) {\n        // Should have positive value.\n        if (_value == 0) {\n            return _error(CHRONOBANK_PLATFORM_INVALID_VALUE);\n        }\n        Asset storage asset = assets[_symbol];\n        uint holderId = getHolderId(msg.sender);\n        // Should have enough tokens.\n        if (asset.wallets[holderId].balance < _value) {\n            return _error(CHRONOBANK_PLATFORM_NOT_ENOUGH_TOKENS);\n        }\n        asset.wallets[holderId].balance = asset.wallets[holderId].balance.sub(_value);\n        asset.totalSupply = asset.totalSupply.sub(_value);\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: n/a after HF 4;\n        // Recursive Call: safe, all changes already made.\n        ChronoBankPlatformEmitter(eventsHistory).emitRevoke(_symbol, _value, _address(holderId));\n        _proxyTransferEvent(holderId, 0, _value, _symbol);\n        return OK;\n    }\n\n    /**\n     * Passes asset ownership to specified address.\n     *\n     * Only ownership is changed, balances are not touched.\n     * Can only be called by asset owner.\n     *\n     * @param _symbol asset symbol.\n     * @param _newOwner address to become a new owner.\n     *\n     * @return success.\n     */\n    function changeOwnership(bytes32 _symbol, address _newOwner) onlyOwner(_symbol) public returns(uint) {\n        if (_newOwner == 0x0) {\n            return _error(CHRONOBANK_PLATFORM_INVALID_NEW_OWNER);\n        }\n\n        Asset storage asset = assets[_symbol];\n        uint newOwnerId = _createHolderId(_newOwner);\n        // Should pass ownership to another holder.\n        if (asset.owner == newOwnerId) {\n            return _error(CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n        }\n        address oldOwner = _address(asset.owner);\n        asset.owner = newOwnerId;\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: n/a after HF 4;\n        // Recursive Call: safe, all changes already made.\n        _delegateAssetOwnerRemoved(_symbol, oldOwner);\n        _delegateAssetOwnerAdded(_symbol, _newOwner);\n        ChronoBankPlatformEmitter(eventsHistory).emitOwnershipChange(oldOwner, _newOwner, _symbol);\n        return OK;\n    }\n\n    /**\n     * Check if specified holder trusts an address with recovery procedure.\n     *\n     * @param _from truster.\n     * @param _to trustee.\n     *\n     * @return trust existance.\n     */\n    function isTrusted(address _from, address _to) constant returns(bool) {\n        return holders[getHolderId(_from)].trust[_to];\n    }\n\n    /**\n     * Trust an address to perform recovery procedure for the caller.\n     *\n     * @param _to trustee.\n     *\n     * @return success.\n     */\n    function trust(address _to) returns(uint) {\n        uint fromId = _createHolderId(msg.sender);\n        // Should trust to another address.\n        if (fromId == getHolderId(_to)) {\n            return _error(CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n        }\n        // Should trust to yet untrusted.\n        if (isTrusted(msg.sender, _to)) {\n            return _error(CHRONOBANK_PLATFORM_ALREADY_TRUSTED);\n        }\n\n        holders[fromId].trust[_to] = true;\n        return OK;\n    }\n\n    /**\n     * Revoke trust to perform recovery procedure from an address.\n     *\n     * @param _to trustee.\n     *\n     * @return success.\n     */\n    function distrust(address _to) checkTrust(msg.sender, _to) public returns (uint) {\n        holders[getHolderId(msg.sender)].trust[_to] = false;\n        return OK;\n    }\n\n    /**\n     * Perform recovery procedure.\n     *\n     * This function logic is actually more of an addAccess(uint _holderId, address _to).\n     * It grants another address access to recovery subject wallets.\n     * Can only be called by trustee of recovery subject.\n     *\n     * @param _from holder address to recover from.\n     * @param _to address to grant access to.\n     *\n     * @return success.\n     */\n    function recover(address _from, address _to) checkTrust(_from, msg.sender) public returns (uint errorCode) {\n        // Should recover to previously unused address.\n        if (getHolderId(_to) != 0) {\n            return _error(CHRONOBANK_PLATFORM_SHOULD_RECOVER_TO_NEW_ADDRESS);\n        }\n        // We take current holder address because it might not equal _from.\n        // It is possible to recover from any old holder address, but event should have the current one.\n        address from = holders[getHolderId(_from)].addr;\n        holders[getHolderId(_from)].addr = _to;\n        holderIndex[_to] = getHolderId(_from);\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        ChronoBankPlatformEmitter(eventsHistory).emitRecovery(from, _to, msg.sender);\n        return OK;\n    }\n\n    /**\n     * Sets asset spending allowance for a specified spender.\n     *\n     * Note: to revoke allowance, one needs to set allowance to 0.\n     *\n     * @param _spenderId holder id to set allowance for.\n     * @param _value amount to allow.\n     * @param _symbol asset symbol.\n     * @param _senderId approve initiator holder id.\n     *\n     * @return success.\n     */\n    function _approve(uint _spenderId, uint _value, bytes32 _symbol, uint _senderId) internal returns(uint) {\n        // Asset should exist.\n        if (!isCreated(_symbol)) {\n            return _error(CHRONOBANK_PLATFORM_ASSET_IS_NOT_ISSUED);\n        }\n        // Should allow to another holder.\n        if (_senderId == _spenderId) {\n            return _error(CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n        }\n\n        // Double Spend Attack checkpoint\n        if (assets[_symbol].wallets[_senderId].allowance[_spenderId] != 0 && _value != 0) {\n            return _error(CHRONOBANK_PLATFORM_INVALID_INVOCATION);\n        }\n\n        assets[_symbol].wallets[_senderId].allowance[_spenderId] = _value;\n\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        ChronoBankPlatformEmitter(eventsHistory).emitApprove(_address(_senderId), _address(_spenderId), _symbol, _value);\n        if (proxies[_symbol] != 0x0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: n/a after HF 4;\n            // Recursive Call: safe, all changes already made.\n            ProxyEventsEmitter(proxies[_symbol]).emitApprove(_address(_senderId), _address(_spenderId), _value);\n        }\n        return OK;\n    }\n\n    /**\n     * Sets asset spending allowance for a specified spender.\n     *\n     * Can only be called by asset proxy.\n     *\n     * @param _spender holder address to set allowance to.\n     * @param _value amount to allow.\n     * @param _symbol asset symbol.\n     * @param _sender approve initiator address.\n     *\n     * @return success.\n     */\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) onlyProxy(_symbol) public returns (uint) {\n        return _approve(_createHolderId(_spender), _value, _symbol, _createHolderId(_sender));\n    }\n\n    /**\n     * Returns asset allowance from one holder to another.\n     *\n     * @param _from holder that allowed spending.\n     * @param _spender holder that is allowed to spend.\n     * @param _symbol asset symbol.\n     *\n     * @return holder to spender allowance.\n     */\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint) {\n        return _allowance(getHolderId(_from), getHolderId(_spender), _symbol);\n    }\n\n    /**\n     * Returns asset allowance from one holder to another.\n     *\n     * @param _fromId holder id that allowed spending.\n     * @param _toId holder id that is allowed to spend.\n     * @param _symbol asset symbol.\n     *\n     * @return holder to spender allowance.\n     */\n    function _allowance(uint _fromId, uint _toId, bytes32 _symbol) constant internal returns(uint) {\n        return assets[_symbol].wallets[_fromId].allowance[_toId];\n    }\n\n    /**\n     * Prforms allowance transfer of asset balance between holders wallets.\n     *\n     * Can only be called by asset proxy.\n     *\n     * @param _from holder address to take from.\n     * @param _to holder address to give to.\n     * @param _value amount to transfer.\n     * @param _symbol asset symbol.\n     * @param _reference transfer comment to be included in a Transfer event.\n     * @param _sender allowance transfer initiator address.\n     *\n     * @return success.\n     */\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) onlyProxy(_symbol) public returns (uint) {\n        return _transfer(getHolderId(_from), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));\n    }\n\n    /**\n    * @dev DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    */\n    function _delegateAssetOwnerAdded(bytes32 _symbol, address _owner) private {\n        if (owningListener != 0x0) {\n            AssetOwningListener(owningListener).assetOwnerAdded(_symbol, this, _owner);\n        }\n    }\n\n    /**\n    * @dev DEPRECATED. WILL BE REMOVED IN NEXT RELEASES\n    */\n    function _delegateAssetOwnerRemoved(bytes32 _symbol, address _owner) private {\n        if (owningListener != 0x0) {\n            AssetOwningListener(owningListener).assetOwnerRemoved(_symbol, this, _owner);\n        }\n    }\n}\n","abiDocs":[{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","return":"asset owner address.","notice":"Returns asset owner address.","signature":"owner(bytes32)","signatureHash":"02571be3"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address","description":"MultiEventsHistory contract address."}],"name":"setupEventsHistory","outputs":[{"name":"errorCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Sets EventsHstory contract address.     * Can be set only by events history admon or owner.","signature":"setupEventsHistory(address)","signatureHash":"02927d20"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset's symbol"},{"name":"_partowner","type":"address","description":"a co-owner of an asset"}],"name":"addAssetPartOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Should be performed by a contract owner or its co-owners","return":"errorCode result code of an operation","notice":"Adds a co-owner for an asset with provided symbol.","signature":"addAssetPartOwner(bytes32,address)","signatureHash":"048ae1bb"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."},{"name":"_value","type":"uint256","description":"amount of tokens to issue immediately."},{"name":"_name","type":"string","description":"name of the asset."},{"name":"_description","type":"string","description":"description for the asset."},{"name":"_baseUnit","type":"uint8","description":"number of decimals."},{"name":"_isReissuable","type":"bool","description":"dynamic or fixed supply."}],"name":"issueAsset","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Issues new asset token on the platform.     * Tokens issued with this call go straight to contract owner. Each symbol can be issued only once, and only by contract owner.","signature":"issueAsset(bytes32,uint256,string,string,uint8,bool)","signatureHash":"085a4705"},{"constant":true,"inputs":[{"name":"_holder","type":"address","description":"holder address."}],"name":"getHolderId","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"holder id.","notice":"Returns holder id for the specified address.","signature":"getHolderId(address)","signatureHash":"0af3e660"},{"constant":false,"inputs":[{"name":"_partowner","type":"address","description":"a co-owner of a contract"}],"name":"removePartOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Should be performed only by root contract owner","return":"result code of an operation","notice":"Removes a co-owner of a contract","signature":"removePartOwner(address)","signatureHash":"1286e393"},{"constant":false,"inputs":[{"name":"_spender","type":"address","description":"holder address to set allowance to."},{"name":"_value","type":"uint256","description":"amount to allow."},{"name":"_symbol","type":"bytes32","description":"asset symbol."},{"name":"_sender","type":"address","description":"approve initiator address."}],"name":"proxyApprove","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Sets asset spending allowance for a specified spender.     * Can only be called by asset proxy.","signature":"proxyApprove(address,uint256,bytes32,address)","signatureHash":"14712e2f"},{"constant":false,"inputs":[{"name":"_from","type":"address","description":"holder address to take from."},{"name":"_to","type":"address","description":"holder address to give to."},{"name":"_value","type":"uint256","description":"amount to transfer."},{"name":"_symbol","type":"bytes32","description":"asset symbol."},{"name":"_reference","type":"string","description":"transfer comment to be included in a Transfer event."},{"name":"_sender","type":"address","description":"allowance transfer initiator address."}],"name":"proxyTransferFromWithReference","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Prforms allowance transfer of asset balance between holders wallets.     * Can only be called by asset proxy.","signature":"proxyTransferFromWithReference(address,address,uint256,bytes32,string,address)","signatureHash":"161ff662"},{"constant":true,"inputs":[{"name":"_from","type":"address","description":"holder that allowed spending."},{"name":"_spender","type":"address","description":"holder that is allowed to spend."},{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"holder to spender allowance.","notice":"Returns asset allowance from one holder to another.","signature":"allowance(address,address,bytes32)","signatureHash":"1c8d5d38"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"holders","payable":false,"stateMutability":"view","type":"function","signature":"holders(uint256)","signatureHash":"2a11ced0"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"isCreated","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","return":"asset existance.","notice":"Check asset existance.","signature":"isCreated(bytes32)","signatureHash":"2f553d31"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Finalize ownership pass.     * Can only be called by pending owner.","signature":"claimContractOwnership()","signatureHash":"4592cd1d"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"trustee."}],"name":"trust","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Trust an address to perform recovery procedure for the caller.","signature":"trust(address)","signatureHash":"4637d827"},{"constant":true,"inputs":[{"name":"_holder","type":"address","description":"holder address."},{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"holder balance.","notice":"Returns asset balance for a particular holder.","signature":"balanceOf(address,bytes32)","signatureHash":"4d30b6be"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"},{"name":"_reference","type":"string"}],"name":"emitTransfer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitTransfer(address,address,bytes32,uint256,string)","signatureHash":"515c1457"},{"constant":false,"inputs":[{"name":"_eventsAdmin","type":"address","description":"admin contract address."}],"name":"setupEventsAdmin","outputs":[{"name":"errorCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Sets EventsHstory contract admin address.     * Can be set only by contract owner.","signature":"setupEventsAdmin(address)","signatureHash":"552f27f5"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"address of the next owner. 0x0 is not allowed."}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Prepares ownership pass.     * Can only be called by current owner.","signature":"changeContractOwnership(address)","signatureHash":"557f4bc9"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"holder address to give to."},{"name":"_value","type":"uint256","description":"amount to transfer."},{"name":"_symbol","type":"bytes32","description":"asset symbol."},{"name":"_reference","type":"string","description":"transfer comment to be included in a Transfer event."},{"name":"_sender","type":"address","description":"transfer initiator address."}],"name":"proxyTransferWithReference","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Transfers asset balance between holders wallets.     * Can only be called by asset proxy.","signature":"proxyTransferWithReference(address,uint256,bytes32,string,address)","signatureHash":"57a96dd0"},{"constant":true,"inputs":[],"name":"pendingContractOwner","payable":false,"stateMutability":"view","type":"function","signature":"pendingContractOwner()","signatureHash":"5aa77d3c"},{"constant":true,"inputs":[{"name":"_holderId","type":"uint256","description":"holder id."},{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"_balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"holder balance.","notice":"Returns asset balance for a particular holder id.","signature":"_balanceOf(uint256,bytes32)","signatureHash":"5b7da338"},{"constant":false,"inputs":[{"name":"_proxyAddress","type":"address","description":"Proxy contract address."},{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"setProxy","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Sets Proxy contract address for a particular asset.     * Can be set only once for each asset, and only by contract owner.","signature":"setProxy(address,bytes32)","signatureHash":"638a9ce9"},{"constant":false,"inputs":[{"name":"_from","type":"address","description":"holder address to recover from."},{"name":"_to","type":"address","description":"address to grant access to."}],"name":"recover","outputs":[{"name":"errorCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Perform recovery procedure.     * This function logic is actually more of an addAccess(uint _holderId, address _to). It grants another address access to recovery subject wallets. Can only be called by trustee of recovery subject.","signature":"recover(address,address)","signatureHash":"648bf774"},{"constant":true,"inputs":[{"name":"_from","type":"address","description":"truster."},{"name":"_to","type":"address","description":"trustee."}],"name":"isTrusted","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","return":"trust existance.","notice":"Check if specified holder trusts an address with recovery procedure.","signature":"isTrusted(address,address)","signatureHash":"6713e230"},{"constant":true,"inputs":[{"name":"_holderId","type":"uint256","description":"holder id."}],"name":"_address","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","return":"holder address.","notice":"Returns current address for a particular holder id.","signature":"_address(uint256)","signatureHash":"6825c843"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function","return":"asset name.","notice":"Returns asset name.","signature":"name(bytes32)","signatureHash":"691f3431"},{"constant":true,"inputs":[{"name":"","type":"bytes32"}],"name":"proxies","payable":false,"stateMutability":"view","type":"function","signature":"proxies(bytes32)","signatureHash":"6932af36"},{"constant":true,"inputs":[],"name":"holdersCount","payable":false,"stateMutability":"view","type":"function","signature":"holdersCount()","signatureHash":"6b4ed21b"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Destroy contract and scrub a data","notice":"Only owner can call it","signature":"destroy()","signatureHash":"83197ef0"},{"constant":false,"inputs":[{"name":"_listener","type":"address"}],"name":"setupAssetOwningListener","payable":false,"stateMutability":"nonpayable","type":"function","details":"DEPRECATED. WILL BE REMOVED IN NEXT RELEASES","signature":"setupAssetOwningListener(address)","signatureHash":"8dcff4f9"},{"constant":true,"inputs":[{"name":"","type":"bytes32"}],"name":"assets","payable":false,"stateMutability":"view","type":"function","signature":"assets(bytes32)","signatureHash":"9fda5b66"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."},{"name":"_value","type":"uint256","description":"amount of tokens to issue immediately."},{"name":"_name","type":"string","description":"name of the asset."},{"name":"_description","type":"string","description":"description for the asset."},{"name":"_baseUnit","type":"uint8","description":"number of decimals."},{"name":"_isReissuable","type":"bool","description":"dynamic or fixed supply."},{"name":"_account","type":"address","description":"address where issued balance will be held"}],"name":"issueAsset","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Issues new asset token on the platform.     * Tokens issued with this call go straight to contract owner. Each symbol can be issued only once, and only by contract owner.","signature":"issueAsset(bytes32,uint256,string,string,uint8,bool,address)","signatureHash":"a3ff0ea2"},{"constant":false,"inputs":[{"name":"_partowner","type":"address","description":"a co-owner of a contract"}],"name":"addPartOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Allowed to only contract onwer","return":"result code of an operation","notice":"Adds a co-owner of a contract. Might be more than one co-owner","signature":"addPartOwner(address)","signatureHash":"a831751d"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"the next contract owner"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Direct ownership pass without change/claim pattern. Can be invoked only by current contract owner","return":"`true` if success, `false` otherwise","signature":"transferContractOwnership(address)","signatureHash":"a843c51f"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_symbol","type":"bytes32"}],"name":"emitOwnershipChange","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitOwnershipChange(address,address,bytes32)","signatureHash":"a9612f72"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"},{"name":"_by","type":"address"}],"name":"emitIssue","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitIssue(bytes32,uint256,address)","signatureHash":"abafaa16"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"asset total supply.","notice":"Returns asset total supply.","signature":"totalSupply(bytes32)","signatureHash":"b524abcf"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"description","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function","return":"asset description.","notice":"Returns asset description.","signature":"description(bytes32)","signatureHash":"bebcc045"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"isReissuable","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","return":"asset reissuability.","notice":"Returns asset reissuability.","signature":"isReissuable(bytes32)","signatureHash":"c4eeeeb9"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"},{"name":"_by","type":"address"}],"name":"emitRevoke","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitRevoke(bytes32,uint256,address)","signatureHash":"c70bbc13"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."},{"name":"_value","type":"uint256","description":"amount of tokens to destroy."}],"name":"revokeAsset","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Destroys specified amount of senders asset tokens.","signature":"revokeAsset(bytes32,uint256)","signatureHash":"ca448a88"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"partowners","payable":false,"stateMutability":"view","type":"function","signature":"partowners(address)","signatureHash":"cb596466"},{"constant":true,"inputs":[{"name":"_owner","type":"address","description":"address to check."},{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"hasAssetRights","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","return":"owner rights availability.","notice":"Checks if a specified address has asset owner or co-owner rights.","signature":"hasAssetRights(address,bytes32)","signatureHash":"ccc11f11"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"symbols","payable":false,"stateMutability":"view","type":"function","signature":"symbols(uint256)","signatureHash":"ccce413b"},{"constant":true,"inputs":[],"name":"contractOwner","payable":false,"stateMutability":"view","type":"function","signature":"contractOwner()","signatureHash":"ce606ee0"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_spender","type":"address"},{"name":"_symbol","type":"bytes32"},{"name":"_value","type":"uint256"}],"name":"emitApprove","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitApprove(address,address,bytes32,uint256)","signatureHash":"d54c8c87"},{"constant":true,"inputs":[],"name":"eventsAdmin","payable":false,"stateMutability":"view","type":"function","signature":"eventsAdmin()","signatureHash":"d8b163d0"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","payable":false,"stateMutability":"nonpayable","type":"function","signature":"withdrawnTokens(address[],address)","signatureHash":"d8f9659b"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"baseUnit","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function","return":"asset decimals.","notice":"Returns asset decimals.","signature":"baseUnit(bytes32)","signatureHash":"dc86e6f0"},{"constant":false,"inputs":[{"name":"_errorCode","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitError(uint256)","signatureHash":"df26ca08"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."},{"name":"_value","type":"uint256","description":"amount of additional tokens to issue."}],"name":"reissueAsset","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Issues additional asset tokens if the asset have dynamic supply.     * Tokens issued with this call go straight to asset owner. Can only be called by asset owner.","signature":"reissueAsset(bytes32,uint256)","signatureHash":"e0873c06"},{"constant":true,"inputs":[{"name":"_owner","type":"address","description":"address to check."},{"name":"_symbol","type":"bytes32","description":"asset symbol."}],"name":"isOwner","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","return":"owner rights availability.","notice":"Check if specified address has asset owner rights.","signature":"isOwner(address,bytes32)","signatureHash":"e96b462a"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_by","type":"address"}],"name":"emitRecovery","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitRecovery(address,address,address)","signatureHash":"ea14457e"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset's symbol"},{"name":"_partowner","type":"address","description":"a co-owner of an asset"}],"name":"removeAssetPartOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Should be performed by a contract owner or its co-owners","return":"errorCode result code of an operation","notice":"Removes a co-owner for an asset with provided symbol.","signature":"removeAssetPartOwner(bytes32,address)","signatureHash":"ec77809f"},{"constant":true,"inputs":[],"name":"symbolsCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"number of symbols","notice":"Provides a cheap way to get number of symbols registered in a platform","signature":"symbolsCount()","signatureHash":"ecac7f4b"},{"constant":true,"inputs":[],"name":"eventsHistory","payable":false,"stateMutability":"view","type":"function","signature":"eventsHistory()","signatureHash":"f07629f8"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"trustee."}],"name":"distrust","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Revoke trust to perform recovery procedure from an address.","signature":"distrust(address)","signatureHash":"f0c06aa5"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"asset symbol."},{"name":"_newOwner","type":"address","description":"address to become a new owner."}],"name":"changeOwnership","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Passes asset ownership to specified address.     * Only ownership is changed, balances are not touched. Can only be called by asset owner.","signature":"changeOwnership(bytes32,address)","signatureHash":"fd83915e"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":true,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"reference","type":"string"}],"name":"Transfer","type":"event","signature":"Transfer(address,address,bytes32,uint256,string)","signatureHash":"8f1b8386"},{"anonymous":false,"inputs":[{"indexed":true,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":true,"name":"by","type":"address"}],"name":"Issue","type":"event","signature":"Issue(bytes32,uint256,address)","signatureHash":"d03c2206"},{"anonymous":false,"inputs":[{"indexed":true,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":true,"name":"by","type":"address"}],"name":"Revoke","type":"event","signature":"Revoke(bytes32,uint256,address)","signatureHash":"a4e2520a"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":true,"name":"symbol","type":"bytes32"}],"name":"OwnershipChange","type":"event","signature":"OwnershipChange(address,address,bytes32)","signatureHash":"0de92ba2"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":true,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approve","type":"event","signature":"Approve(address,address,bytes32,uint256)","signatureHash":"859b1cdd"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"by","type":"address"}],"name":"Recovery","type":"event","signature":"Recovery(address,address,address)","signatureHash":"6c046851"},{"anonymous":false,"inputs":[{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event","signature":"Error(uint256)","signatureHash":"2e36a709"}]}
