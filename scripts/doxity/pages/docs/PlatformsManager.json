{"title":"Defines implementation for managing platforms creation and tracking system's platforms. Some methods could require to pay additional fee in TIMEs during their invocation.","fileName":"/contracts/assets/PlatformsManager.sol","name":"PlatformsManager","abi":[{"constant":false,"inputs":[{"name":"_platform","type":"address"}],"name":"attachPlatform","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"getPlatformsForUserCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_by","type":"address"}],"name":"emitPlatformDetached","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_tokenExtension","type":"address"},{"name":"_by","type":"address"}],"name":"emitPlatformRequested","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_by","type":"address"}],"name":"emitPlatformAttached","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32"}],"name":"lookupManager","outputs":[{"name":"manager","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"contractsManager","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"pendingContractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_platform","type":"address"}],"name":"detachPlatform","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"getPlatformsMetadataForUser","outputs":[{"name":"_platforms","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"createPlatform","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"},{"name":"_idx","type":"uint256"}],"name":"getPlatformForUserAtIndex","outputs":[{"name":"_platform","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_platform","type":"address"}],"name":"isPlatformAttached","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"contractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_errorCode","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"},{"name":"_platformsFactory","type":"address"}],"name":"init","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_from","type":"address"}],"name":"replaceAssociatedPlatformFromOwner","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_fromPlatform","type":"address"},{"name":"_toPlatform","type":"address"}],"name":"emitPlatformReplaced","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getEventsHistory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":true,"name":"by","type":"address"}],"name":"PlatformAttached","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":true,"name":"by","type":"address"}],"name":"PlatformDetached","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":false,"name":"tokenExtension","type":"address"},{"indexed":true,"name":"by","type":"address"}],"name":"PlatformRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"fromPlatform","type":"address"},{"indexed":false,"name":"toPlatform","type":"address"}],"name":"PlatformReplaced","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event"}],"source":"pragma solidity ^0.4.11;\n\nimport \"../core/common/BaseManager.sol\";\nimport \"../timeholder/FeatureFeeAdapter.sol\";\nimport \"../core/common/OwnedInterface.sol\";\nimport \"../core/platform/ChronoBankAssetOwnershipManager.sol\";\nimport \"./PlatformsManagerEmitter.sol\";\nimport \"./AssetsManagerInterface.sol\";\nimport \"./PlatformsManagerInterface.sol\";\nimport \"../core/platform/ChronoBankPlatform.sol\";\nimport \"./AssetOwnershipDelegateResolver.sol\";\n\n\ncontract PlatformsFactory {\n    function createPlatform(address owner, address eventsHistory, address eventsHistoryAdmin) returns (address);\n}\n\n\ncontract OwnedContract {\n    address public contractOwner;\n}\n\n\n/**\n* @title Defines implementation for managing platforms creation and tracking system's platforms.\n* Some methods could require to pay additional fee in TIMEs during their invocation.\n*/\ncontract PlatformsManager is FeatureFeeAdapter, BaseManager, PlatformsManagerEmitter, PlatformsManagerInterface {\n\n    /** Error codes */\n\n    uint constant ERROR_PLATFORMS_ATTACHING_PLATFORM_ALREADY_EXISTS = 21001;\n    uint constant ERROR_PLATFORMS_PLATFORM_DOES_NOT_EXIST = 21002;\n    uint constant ERROR_PLATFORMS_INCONSISTENT_INTERNAL_STATE = 21003;\n    uint constant ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED = 21005;\n    uint constant ERROR_PLATFORMS_CANNOT_UPDATE_EVENTS_HISTORY_NOT_EVENTS_ADMIN = 21006;\n\n    uint constant PLATFORM_ATTACH_SYNC_DONE = 2**255;\n    uint constant PLATFORM_DETACH_SYNC_DONE = 2**255-1;\n\n    /** Storage keys */\n\n    /** @dev address of platforms factory contract */\n    StorageInterface.Address platformsFactory;\n\n    /** @dev mapping (address => set(address)) stands for (owner => set(platform)) */\n    StorageInterface.AddressesSetMapping ownerToPlatforms;\n\n    /** @dev set(address) stands for set(platform) */\n    StorageInterface.OrderedAddressesSet platforms;\n\n    /** @dev mapping (address => uint256) stands for (platform => index) */\n    StorageInterface.AddressUIntMapping syncPlatformToSymbolIdx;\n\n    /**\n    * @dev Guards methods for only platform owners\n    */\n    modifier onlyPlatformOwner(address _platform) {\n        if (_isPlatformOwner(_platform)) {\n            _;\n        }\n    }\n\n    /**\n    * @dev Guards methods for contracts that was platorm's owners the last time they were accessed\n    */\n    modifier onlyPreviousPlatformOwner(address _platform, address _previousOwner) {\n        if (store.includes(ownerToPlatforms, bytes32(_previousOwner), _platform)) {\n            _;\n        }\n    }\n\n    function PlatformsManager(Storage _store, bytes32 _crate) BaseManager(_store, _crate) {\n        platformsFactory.init(\"platformsFactory\");\n        ownerToPlatforms.init(\"v1ownerToPlatforms\");\n        platforms.init(\"v1platforms\");\n        syncPlatformToSymbolIdx.init(\"v1syncPlatformToSymbolIdx\");\n    }\n\n    function init(address _contractsManager, address _platformsFactory) onlyContractOwner public returns (uint) {\n        BaseManager.init(_contractsManager, \"PlatformsManager\");\n\n        store.set(platformsFactory, _platformsFactory);\n\n        return OK;\n    }\n\n    /**\n    * @dev Returns a platform owned by passed user by accessing it by index that is registered in the system.\n    *\n    * @param _user associated owner of platforms\n    * @param _idx index of a platform\n    *\n    * @return _platform platform address\n    */\n    function getPlatformForUserAtIndex(address _user, uint _idx) public constant returns (address _platform) {\n        _platform = store.get(ownerToPlatforms, bytes32(_user), _idx);\n    }\n\n    /**\n    * @dev Gets number of platform that are owned by passed user.\n    *\n    * @param _user associated owner of platforms\n    *\n    * @return number of platforms owned by user\n    */\n    function getPlatformsForUserCount(address _user) public constant returns (uint) {\n        return store.count(ownerToPlatforms, bytes32(_user));\n    }\n\n    /**\n    * @dev Gets list of platforms owned by passed user\n    *\n    * @param _user associated owner of platforms\n    *\n    * @return _platforms list of platforms owned by user\n    */\n    function getPlatformsMetadataForUser(address _user) public constant returns (address[] _platforms) {\n        _platforms = store.get(ownerToPlatforms, bytes32(_user));\n    }\n\n    /**\n    * @dev Checks if passed platform is presented in the system\n    *\n    * @param _platform platform address\n    *\n    * @return `true` if it is registered, `false` otherwise\n    */\n    function isPlatformAttached(address _platform) public constant returns (bool) {\n        return store.includes(platforms, _platform);\n    }\n\n    /**\n    * @dev Responsible for registering an existed platform in the system. Could be performed only by owner of passed platform.\n    * It also reset platform's event history to system's one, so an owner should install PlatformsManager as eventsAdmin in its\n    * platform contract.\n    *\n    * Attaching a new platform also leads to synchronyzing all assets hosted in a platform and their owners so it is possible\n    * in case when a platform has a lot of assets and managers that this process of registering a platform will end up with\n    * ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED error. It means that all goes right just keep calling this method until\n    * `OK` result code will be returned; synchronysation might take several attemtps before it will be finished.\n    *\n    * @param _platform platform address\n    *\n    * @return resultCode result code of an operation.\n    *   ERROR_PLATFORMS_ATTACHING_PLATFORM_ALREADY_EXISTS,\n    *   ERROR_PLATFORMS_CANNOT_UPDATE_EVENTS_HISTORY_NOT_EVENTS_ADMIN,\n    *   ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED might be returned.\n    */\n    function attachPlatform(address _platform) onlyPlatformOwner(_platform) public returns (uint resultCode) {\n        if (store.includes(platforms, _platform)) {\n            return _emitError(ERROR_PLATFORMS_ATTACHING_PLATFORM_ALREADY_EXISTS);\n        }\n\n        resultCode = _syncAssetsInPlatformBeforeAttach(_platform);\n        if (resultCode != OK) {\n            return _emitError(resultCode);\n        }\n\n        _attachPlatformWithoutValidation(_platform, OwnedContract(_platform).contractOwner());\n        if (OK != ChronoBankPlatform(_platform).setupEventsHistory(getEventsHistory())) {\n            _emitError(ERROR_PLATFORMS_CANNOT_UPDATE_EVENTS_HISTORY_NOT_EVENTS_ADMIN);\n        }\n\n        _emitPlatformAttached(_platform, msg.sender);\n\n        return OK;\n    }\n\n    /**\n    * @dev Responsible for removing a platform from the system. Could be performed only by owner of passed platform.\n    * It also reset platform's eventsHistory and set platform as a new eventsHistory; still PlatformsManager should\n    * be eventsAdmin in a platform.\n    *\n    * Detaching process also includes removal of all assets and managers from system's registry, so as an opposite\n    * to a synchronization during attaching this process clean up all records about assets and their owners. It could\n    * take several attempts until all data will be removed. ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED will be returned\n    * in case if clean up process is not going to finish during this iteration so keep calling until `OK` will be a result.\n    *\n    * @param _platform platform address\n    *\n    * @return resultCode result code of an operation.\n    *   ERROR_PLATFORMS_PLATFORM_DOES_NOT_EXIST,\n    *   ERROR_PLATFORMS_INCONSISTENT_INTERNAL_STATE,\n    *   ERROR_PLATFORMS_CANNOT_UPDATE_EVENTS_HISTORY_NOT_EVENTS_ADMIN,\n    *   ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED might be returned.\n    */\n    function detachPlatform(address _platform) onlyPlatformOwner(_platform) public returns (uint resultCode) {\n        if (!store.includes(platforms, _platform)) {\n            return _emitError(ERROR_PLATFORMS_PLATFORM_DOES_NOT_EXIST);\n        }\n\n        address _owner = OwnedContract(_platform).contractOwner();\n        if (!store.includes(ownerToPlatforms, bytes32(_owner), _platform)) {\n            return _emitError(ERROR_PLATFORMS_INCONSISTENT_INTERNAL_STATE);\n        }\n\n        resultCode = _syncAssetsInPlatformBeforeDetach(_platform);\n        if (resultCode != OK) {\n            return _emitError(resultCode);\n        }\n\n        if (OK != ChronoBankPlatform(_platform).setupEventsHistory(_platform)) {\n            _emitError(ERROR_PLATFORMS_CANNOT_UPDATE_EVENTS_HISTORY_NOT_EVENTS_ADMIN);\n        }\n\n        store.remove(ownerToPlatforms, bytes32(_owner), _platform);\n        store.remove(platforms, _platform);\n\n        _emitPlatformDetached(_platform, msg.sender);\n        return OK;\n    }\n\n    /**\n    * @dev Designed to keep PlatformsManager in consistent state when platform's owner might be changed.\n    * New owner of a platform should call this method to update a record about platform ownership.\n    * Until this operation would not be performed, then user of a platform couldn't do anything with this\n    * platform.\n    *\n    * @param _platform platform address\n    * @param _from previous owner of a platform*\n    *\n    * @return resultCode result code of an operation.\n    */\n    function replaceAssociatedPlatformFromOwner(address _platform, address _from)\n    onlyPlatformOwner(_platform)\n    onlyPreviousPlatformOwner(_platform, _from)\n    public returns (uint resultCode) {\n        store.add(ownerToPlatforms, bytes32(msg.sender), _platform);\n        store.remove(ownerToPlatforms, bytes32(_from), _platform);\n        return OK;\n    }\n\n    /**\n    * @dev Creates a brand new platform.\n    * This method might take an additional fee in TIMEs.\n    *\n    * @return resultCode result code of an operation\n    */\n    function createPlatform() public returns (uint resultCode) {\n        return _createPlatform([uint(0)]);\n    }\n\n    function _createPlatform(uint[1] memory _result)\n    private\n    featured(_result)\n    returns (uint resultCode)\n    {\n        PlatformsFactory factory = PlatformsFactory(store.get(platformsFactory));\n        address _platform = factory.createPlatform(msg.sender, getEventsHistory(), this);\n        _attachPlatformWithoutValidation(_platform, msg.sender);\n\n        AssetsManagerInterface assetsManager = AssetsManagerInterface(lookupManager(\"AssetsManager\"));\n        resultCode = assetsManager.requestTokenExtension(_platform);\n        address _tokenExtension;\n        if (resultCode == OK) {\n            _tokenExtension = assetsManager.getTokenExtension(_platform);\n            ChronoBankAssetOwnershipManager(_platform).addPartOwner(_tokenExtension);\n        }\n\n        OwnedInterface(_platform).transferContractOwnership(msg.sender);\n        _emitPlatformRequested(_platform, _tokenExtension, msg.sender);\n        return OK;\n    }\n\n    /**\n    * @dev Sets up internal variables during a platform attach. PRIVATE\n    */\n    function _attachPlatformWithoutValidation(address _platform, address _owner) private {\n        store.add(ownerToPlatforms, bytes32(_owner), _platform);\n        store.add(platforms, _platform);\n    }\n\n    /**\n    * @dev Checks if passed platform is owned by msg.sender. PRIVATE\n    */\n    function _isPlatformOwner(address _platform) private constant returns (bool) {\n        return OwnedContract(_platform).contractOwner() == msg.sender;\n    }\n\n    /**\n    * @dev Performs synchronization during attaching platforms. PRIVATE\n    */\n    function _syncAssetsInPlatformBeforeAttach(address _platform) private returns (uint resultCode) {\n        uint _lastSyncIdx = store.get(syncPlatformToSymbolIdx, _platform);\n        if (_lastSyncIdx == PLATFORM_DETACH_SYNC_DONE) {\n            _lastSyncIdx = 0;\n        }\n\n        if (_lastSyncIdx != PLATFORM_ATTACH_SYNC_DONE) {\n            AssetOwningListener _assetOwnershipResolver = AssetOwningListener(lookupManager(\"AssetOwnershipResolver\"));\n            resultCode = _runThroughPlatform(_lastSyncIdx, _platform, _assetOwnershipResolver.assetOwnerAdded);\n            if (resultCode != OK) {\n                return resultCode;\n            }\n\n            store.set(syncPlatformToSymbolIdx, _platform, PLATFORM_ATTACH_SYNC_DONE);\n        }\n\n        return OK;\n    }\n\n    /**\n    * @dev Performs synchronization during detaching platforms. PRIVATE\n    */\n    function _syncAssetsInPlatformBeforeDetach(address _platform) private returns (uint resultCode) {\n        uint _lastSyncIdx = store.get(syncPlatformToSymbolIdx, _platform);\n        if (_lastSyncIdx == PLATFORM_ATTACH_SYNC_DONE) {\n            _lastSyncIdx = 0;\n        }\n\n        if (_lastSyncIdx != PLATFORM_DETACH_SYNC_DONE) {\n            AssetOwningListener _assetOwnershipResolver = AssetOwningListener(lookupManager(\"AssetOwnershipResolver\"));\n            resultCode = _runThroughPlatform(_lastSyncIdx, _platform, _assetOwnershipResolver.assetOwnerRemoved);\n            if (resultCode != OK) {\n                return resultCode;\n            }\n\n            store.set(syncPlatformToSymbolIdx, _platform, PLATFORM_DETACH_SYNC_DONE);\n        }\n\n        return OK;\n    }\n\n    /**\n    * @dev Main synchronization method during attach/detach. PRIVATE\n    */\n    function _runThroughPlatform(uint _lastSyncIdx, address _platform, function (bytes32, address, address) external ownerUpdate) private returns (uint) {\n        ChronoBankAssetOwnershipManager _chronoBankPlatform = ChronoBankAssetOwnershipManager(_platform);\n        ChronoBankManagersRegistry _chronoBankRegistry = ChronoBankManagersRegistry(_platform);\n\n        uint _symbolsCount = _chronoBankPlatform.symbolsCount();\n        uint _holdersCount = _chronoBankRegistry.holdersCount();\n\n        bool _shouldInitHolders = true;\n        address[] memory _holders = new address[](_holdersCount);\n\n        for (; _lastSyncIdx < _symbolsCount; ++_lastSyncIdx) {\n            if (msg.gas < 100000) {\n                store.set(syncPlatformToSymbolIdx, _platform, _lastSyncIdx);\n                return ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED;\n            }\n\n            bytes32 _symbol = _chronoBankPlatform.symbols(_lastSyncIdx);\n            for (uint _holderIdx = 0; _holderIdx < _holdersCount; ++_holderIdx) {\n                if (_shouldInitHolders) {\n                    _holders[_holderIdx] = _chronoBankRegistry.holders(_holderIdx);\n                }\n\n                if (_chronoBankPlatform.hasAssetRights(_holders[_holderIdx], _symbol)) {\n                    ownerUpdate(_symbol, _platform, _holders[_holderIdx]);\n                }\n            }\n\n            _shouldInitHolders = false;\n        }\n\n        return OK;\n    }\n\n    /**\n    * Events emitting\n    */\n\n    function _emitError(uint _errorCode) private returns (uint) {\n        PlatformsManagerEmitter(getEventsHistory()).emitError(_errorCode);\n        return _errorCode;\n    }\n\n    function _emitPlatformAttached(address _platform, address _by) private {\n        PlatformsManagerEmitter(getEventsHistory()).emitPlatformAttached(_platform, _by);\n    }\n\n    function _emitPlatformDetached(address _platform, address _by) private {\n        PlatformsManagerEmitter(getEventsHistory()).emitPlatformDetached(_platform, _by);\n    }\n\n    function _emitPlatformRequested(address _platform, address _tokenExtension, address sender) private {\n        PlatformsManagerEmitter(getEventsHistory()).emitPlatformRequested(_platform, _tokenExtension, sender);\n    }\n\n    /**\n    * @dev DEPRECATED. WILL BE REMOVED IN FUTURE RELEASES\n    */\n    function _emitPlatformReplaced(address _fromPlatform, address _toPlatform) private {\n        PlatformsManagerEmitter(getEventsHistory()).emitPlatformReplaced(_fromPlatform, _toPlatform);\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[{"name":"_platform","type":"address","description":"platform address"}],"name":"attachPlatform","outputs":[{"name":"resultCode","type":"uint256","description":"result code of an operation.  ERROR_PLATFORMS_ATTACHING_PLATFORM_ALREADY_EXISTS,  ERROR_PLATFORMS_CANNOT_UPDATE_EVENTS_HISTORY_NOT_EVENTS_ADMIN,  ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED might be returned."}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Responsible for registering an existed platform in the system. Could be performed only by owner of passed platform. It also reset platform's event history to system's one, so an owner should install PlatformsManager as eventsAdmin in its platform contract.    * Attaching a new platform also leads to synchronyzing all assets hosted in a platform and their owners so it is possible in case when a platform has a lot of assets and managers that this process of registering a platform will end up with ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED error. It means that all goes right just keep calling this method until `OK` result code will be returned; synchronysation might take several attemtps before it will be finished.","return":"resultCode result code of an operation.  ERROR_PLATFORMS_ATTACHING_PLATFORM_ALREADY_EXISTS,  ERROR_PLATFORMS_CANNOT_UPDATE_EVENTS_HISTORY_NOT_EVENTS_ADMIN,  ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED might be returned.","signature":"attachPlatform(address)","signatureHash":"19e77baf"},{"constant":true,"inputs":[{"name":"_user","type":"address","description":"associated owner of platforms"}],"name":"getPlatformsForUserCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets number of platform that are owned by passed user.","return":"number of platforms owned by user","signature":"getPlatformsForUserCount(address)","signatureHash":"2197cc34"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_by","type":"address"}],"name":"emitPlatformDetached","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitPlatformDetached(address,address)","signatureHash":"237932cf"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Finalize ownership pass.     * Can only be called by pending owner.","signature":"claimContractOwnership()","signatureHash":"4592cd1d"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_tokenExtension","type":"address"},{"name":"_by","type":"address"}],"name":"emitPlatformRequested","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitPlatformRequested(address,address,address)","signatureHash":"47ab61b4"},{"constant":false,"inputs":[{"name":"_platform","type":"address"},{"name":"_by","type":"address"}],"name":"emitPlatformAttached","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","notice":"Emitting events","signature":"emitPlatformAttached(address,address)","signatureHash":"4ddeb7d5"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32","description":"is a manager's identifier. 0x0 is not allowed."}],"name":"lookupManager","payable":false,"stateMutability":"view","type":"function","details":"Returns manager's address by its identifier (type).","notice":"Will crash if no manager in the system with given identifier.","signature":"lookupManager(bytes32)","signatureHash":"4fe59012"},{"constant":true,"inputs":[],"name":"contractsManager","payable":false,"stateMutability":"view","type":"function","signature":"contractsManager()","signatureHash":"53253d31"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"address of the next owner. 0x0 is not allowed."}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Prepares ownership pass.     * Can only be called by current owner.","signature":"changeContractOwnership(address)","signatureHash":"557f4bc9"},{"constant":true,"inputs":[],"name":"pendingContractOwner","payable":false,"stateMutability":"view","type":"function","signature":"pendingContractOwner()","signatureHash":"5aa77d3c"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"setEventsHistory(address)","signatureHash":"6521afd7"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address","description":"contracts manager. 0x0 is not allowed."}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Setter for ContractsManager. Force overrides currect manager.","signature":"setContractsManager(address)","signatureHash":"71d3b573"},{"constant":false,"inputs":[{"name":"_platform","type":"address","description":"platform address"}],"name":"detachPlatform","outputs":[{"name":"resultCode","type":"uint256","description":"result code of an operation.  ERROR_PLATFORMS_PLATFORM_DOES_NOT_EXIST,  ERROR_PLATFORMS_INCONSISTENT_INTERNAL_STATE,  ERROR_PLATFORMS_CANNOT_UPDATE_EVENTS_HISTORY_NOT_EVENTS_ADMIN,  ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED might be returned."}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Responsible for removing a platform from the system. Could be performed only by owner of passed platform. It also reset platform's eventsHistory and set platform as a new eventsHistory; still PlatformsManager should be eventsAdmin in a platform.    * Detaching process also includes removal of all assets and managers from system's registry, so as an opposite to a synchronization during attaching this process clean up all records about assets and their owners. It could take several attempts until all data will be removed. ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED will be returned in case if clean up process is not going to finish during this iteration so keep calling until `OK` will be a result.","return":"resultCode result code of an operation.  ERROR_PLATFORMS_PLATFORM_DOES_NOT_EXIST,  ERROR_PLATFORMS_INCONSISTENT_INTERNAL_STATE,  ERROR_PLATFORMS_CANNOT_UPDATE_EVENTS_HISTORY_NOT_EVENTS_ADMIN,  ERROR_PLATFORMS_REPEAT_SYNC_IS_NOT_COMPLETED might be returned.","signature":"detachPlatform(address)","signatureHash":"73583f98"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"destroy()","signatureHash":"83197ef0"},{"constant":true,"inputs":[{"name":"_user","type":"address","description":"associated owner of platforms"}],"name":"getPlatformsMetadataForUser","outputs":[{"name":"_platforms","type":"address[]","description":"list of platforms owned by user"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets list of platforms owned by passed user","return":"_platforms list of platforms owned by user","signature":"getPlatformsMetadataForUser(address)","signatureHash":"843a5974"},{"constant":false,"inputs":[],"name":"createPlatform","outputs":[{"name":"resultCode","type":"uint256","description":"result code of an operation"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Creates a brand new platform. This method might take an additional fee in TIMEs.","return":"resultCode result code of an operation","signature":"createPlatform()","signatureHash":"8c1ae7f5"},{"constant":true,"inputs":[{"name":"_user","type":"address","description":"associated owner of platforms"},{"name":"_idx","type":"uint256","description":"index of a platform"}],"name":"getPlatformForUserAtIndex","outputs":[{"name":"_platform","type":"address","description":"platform address"}],"payable":false,"stateMutability":"view","type":"function","details":"Returns a platform owned by passed user by accessing it by index that is registered in the system.","return":"_platform platform address","signature":"getPlatformForUserAtIndex(address,uint256)","signatureHash":"a43ee2eb"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"the next contract owner"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Direct ownership pass without change/claim pattern. Can be invoked only by current contract owner","return":"`true` if success, `false` otherwise","signature":"transferContractOwnership(address)","signatureHash":"a843c51f"},{"constant":true,"inputs":[{"name":"_platform","type":"address","description":"platform address"}],"name":"isPlatformAttached","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","details":"Checks if passed platform is presented in the system","return":"`true` if it is registered, `false` otherwise","signature":"isPlatformAttached(address)","signatureHash":"c7eff32e"},{"constant":true,"inputs":[],"name":"contractOwner","payable":false,"stateMutability":"view","type":"function","signature":"contractOwner()","signatureHash":"ce606ee0"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","payable":false,"stateMutability":"nonpayable","type":"function","signature":"withdrawnTokens(address[],address)","signatureHash":"d8f9659b"},{"constant":false,"inputs":[{"name":"_errorCode","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitError(uint256)","signatureHash":"df26ca08"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"},{"name":"_platformsFactory","type":"address"}],"name":"init","payable":false,"stateMutability":"nonpayable","type":"function","signature":"init(address,address)","signatureHash":"f09a4016"},{"constant":false,"inputs":[{"name":"_platform","type":"address","description":"platform address"},{"name":"_from","type":"address","description":"previous owner of a platform*"}],"name":"replaceAssociatedPlatformFromOwner","outputs":[{"name":"resultCode","type":"uint256","description":"result code of an operation."}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Designed to keep PlatformsManager in consistent state when platform's owner might be changed. New owner of a platform should call this method to update a record about platform ownership. Until this operation would not be performed, then user of a platform couldn't do anything with this platform.","return":"resultCode result code of an operation.","signature":"replaceAssociatedPlatformFromOwner(address,address)","signatureHash":"f942be26"},{"constant":false,"inputs":[{"name":"_fromPlatform","type":"address"},{"name":"_toPlatform","type":"address"}],"name":"emitPlatformReplaced","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"DEPRECATED. WILL BE REMOVED IN FUTURE RELEASES","signature":"emitPlatformReplaced(address,address)","signatureHash":"fa542bc8"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","payable":false,"stateMutability":"view","type":"function","signature":"isAuthorized(address)","signatureHash":"fe9fbb80"},{"constant":true,"inputs":[],"name":"getEventsHistory","payable":false,"stateMutability":"view","type":"function","signature":"getEventsHistory()","signatureHash":"fff10aba"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":true,"name":"by","type":"address"}],"name":"PlatformAttached","type":"event","signature":"PlatformAttached(address,address,address)","signatureHash":"cdc5b8b2"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":true,"name":"by","type":"address"}],"name":"PlatformDetached","type":"event","signature":"PlatformDetached(address,address,address)","signatureHash":"91fa8213"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"platform","type":"address"},{"indexed":false,"name":"tokenExtension","type":"address"},{"indexed":true,"name":"by","type":"address"}],"name":"PlatformRequested","type":"event","signature":"PlatformRequested(address,address,address,address)","signatureHash":"675ebf44"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"fromPlatform","type":"address"},{"indexed":false,"name":"toPlatform","type":"address"}],"name":"PlatformReplaced","type":"event","signature":"PlatformReplaced(address,address,address)","signatureHash":"d7ce3ddd"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event","signature":"Error(address,uint256)","signatureHash":"9cf38cf2"}]}
