{"fileName":"/contracts/wallet/Wallet.sol","name":"multiowned","abi":[{"constant":false,"inputs":[{"name":"errorCode","type":"uint256"}],"name":"_emitError","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"_emitSingleTransact","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"emitOwnerAdded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"}],"name":"emitConfirmation","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_owner","type":"address"}],"name":"removeOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"from","type":"address"},{"name":"value","type":"uint256"}],"name":"emitDeposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_addr","type":"address"}],"name":"isOwner","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"toggle2FA","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"m_numOwners","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"newRequirement","type":"uint256"}],"name":"emitRequirementChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"enabled","type":"bool"}],"name":"emit2FAChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"emitMultiTransact","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"version","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"operation","type":"bytes32"},{"name":"initiator","type":"address"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"_emitConfirmationNeeded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"oldOwner","type":"address"},{"name":"newOwner","type":"address"}],"name":"emitOwnerChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"oldOwner","type":"address"}],"name":"emitOwnerRemoved","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"}],"name":"_emitConfirmation","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_owner","type":"address"}],"name":"addOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"m_required","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"emitSingleTransact","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"oldOwner","type":"address"}],"name":"_emitOwnerRemoved","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"}],"name":"_emitRevoke","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"use2FA","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"enabled","type":"bool"}],"name":"_emit2FAChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_operation","type":"bytes32"}],"name":"revoke","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_newRequired","type":"uint256"}],"name":"changeRequirement","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"newRequirement","type":"uint256"}],"name":"_emitRequirementChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"_emitOwnerAdded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_operation","type":"bytes32"},{"name":"_owner","type":"address"}],"name":"hasConfirmed","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"ownerIndex","type":"uint256"}],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"}],"name":"emitRevoke","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"oldOwner","type":"address"},{"name":"newOwner","type":"address"}],"name":"_emitOwnerChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"errorCode","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"from","type":"address"},{"name":"value","type":"uint256"}],"name":"_emitDeposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"operation","type":"bytes32"},{"name":"initiator","type":"address"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"emitConfirmationNeeded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"}],"name":"changeOwner","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"_emitMultiTransact","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getEventsHistory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_owners","type":"address[]"},{"name":"_required","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"from","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"MultisigWalletDeposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"to","type":"address"},{"indexed":false,"name":"symbol","type":"bytes32"}],"name":"MultisigWalletSingleTransact","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"operation","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"to","type":"address"},{"indexed":false,"name":"symbol","type":"bytes32"}],"name":"MultisigWalletMultiTransact","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"operation","type":"bytes32"},{"indexed":true,"name":"initiator","type":"address"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"to","type":"address"},{"indexed":false,"name":"symbol","type":"bytes32"}],"name":"MultisigWalletConfirmationNeeded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"operation","type":"bytes32"}],"name":"MultisigWalletConfirmation","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"operation","type":"bytes32"}],"name":"MultisigWalletRevoke","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"oldOwner","type":"address"},{"indexed":true,"name":"newOwner","type":"address"}],"name":"MultisigWalletOwnerChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"newOwner","type":"address"}],"name":"MultisigWalletOwnerAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"oldOwner","type":"address"}],"name":"MultisigWalletOwnerRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"newRequirement","type":"uint256"}],"name":"MultisigWalletRequirementChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"enabled","type":"bool"}],"name":"MultisigWallet2FAChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event"}],"source":"//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.11;\n\nimport {ERC20ManagerInterface as ERC20Manager} from \"../core/erc20/ERC20ManagerInterface.sol\";\nimport {ContractsManagerInterface as ContractsManager} from \"../core/contracts/ContractsManagerInterface.sol\";\nimport \"../core/erc20/ERC20Interface.sol\";\nimport \"./WalletEmitter.sol\";\n\ncontract WalletsManagerInterface {\n    function removeWallet() returns (uint);\n    function getOracleAddress() constant returns (address);\n    function getOraclePrice() constant returns (uint);\n}\n\ncontract multiowned is WalletEmitter {\n\n\t// TYPES\n\n    uint constant WALLET_INVALID_INVOCATION = 14010;\n    uint constant OK = 1;\n    uint constant WALLET_UNKNOWN_OWNER = 14012;\n    uint constant WALLET_OWNER_ALREADY_EXISTS = 14013;\n    uint constant WALLET_CONFIRMATION_NEEDED = 14014;\n    uint constant WALLET_UNKNOWN_OPERATION = 14015;\n    uint constant WALLET_OWNERS_LIMIT_EXIDED = 14016;\n    uint constant WALLET_UNKNOWN_TOKEN_TRANSFER = 14017;\n    uint constant WALLET_TRANSFER_ALREADY_REGISTERED = 14018;\n    uint constant WALLET_INSUFFICIENT_BALANCE = 14019;\n    uint constant WALLET_RELEASE_TIME_ERROR = 14020;\n\n    address eventsEmmiter;\n\n    address contractsManager;\n\n    // struct for the status of a pending operation.\n    struct PendingState {\n        uint yetNeeded;\n        uint ownersDone;\n        uint index;\n    }\n\n    modifier non2FA() {\n        if(use2FA) {\n            uint errorCode = WALLET_INVALID_INVOCATION;\n            assembly {\n                mstore(0, errorCode)\n                return(0, 32)\n            }\n        }\n        assert(!use2FA);\n\n        _;\n    }\n\t// METHODS\n\n    function getEventsHistory() constant returns (address) {\n        return eventsEmmiter;\n    }\n\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n    // as well as the selection of addresses capable of confirming them.\n    function multiowned(address[] _owners, uint _required) {\n        if(_owners.length == 0) {\n            revert();\n        }\n        for (uint i = 0; i < _owners.length; i++)\n        {\n            m_owners[1 + i] = uint(_owners[i]);\n            m_ownerIndex[uint(_owners[i])] = 1 + i;\n            m_numOwners++;\n        }\n        if(_required <= m_numOwners) {\n            m_required = _required;\n        }\n        else {\n            m_required = m_numOwners;\n        }\n    }\n\n    // Revokes a prior confirmation of the given operation\n    function revoke(bytes32 _operation) external returns (uint) {\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n        // make sure they're an owner\n        if (ownerIndex == 0) return _emitError(WALLET_UNKNOWN_OWNER);\n        uint ownerIndexBit = 2**ownerIndex;\n        var pending = m_pending[_operation];\n        if (pending.ownersDone & ownerIndexBit > 0) {\n            pending.yetNeeded++;\n            pending.ownersDone -= ownerIndexBit;\n            _emitRevoke(msg.sender, _operation);\n            return OK;\n        }\n        return _emitError(WALLET_UNKNOWN_OPERATION);\n    }\n\n    // Replaces an owner `_from` with another `_to`.\n    function changeOwner(address _from, address _to) external non2FA returns (uint) {\n        uint e = confirmAndCheck(sha3(msg.data));\n        if(OK != e) {\n            return _emitError(e);\n        }\n        if (isOwner(_to)) return _emitError(WALLET_OWNER_ALREADY_EXISTS);\n        uint ownerIndex = m_ownerIndex[uint(_from)];\n        if (ownerIndex == 0) return _emitError(WALLET_UNKNOWN_OWNER);\n        clearPending();\n        m_owners[ownerIndex] = uint(_to);\n        m_ownerIndex[uint(_from)] = 0;\n        m_ownerIndex[uint(_to)] = ownerIndex;\n        _emitOwnerChanged(_from, _to);\n        return OK;\n    }\n\n    function addOwner(address _owner) external non2FA returns (uint) {\n        uint e = confirmAndCheck(sha3(msg.data));\n        if(OK != e) {\n            return _emitError(e);\n        }\n        if (isOwner(_owner)) return _emitError(WALLET_OWNER_ALREADY_EXISTS);\n\n        clearPending();\n        if (m_numOwners >= c_maxOwners)\n            reorganizeOwners();\n        if (m_numOwners >= c_maxOwners)\n            return WALLET_OWNERS_LIMIT_EXIDED;\n        m_numOwners++;\n        m_owners[m_numOwners] = uint(_owner);\n        m_ownerIndex[uint(_owner)] = m_numOwners;\n        _emitOwnerAdded(_owner);\n        return OK;\n    }\n\n    function removeOwner(address _owner) external non2FA returns (uint) {\n        uint e = confirmAndCheck(sha3(msg.data));\n        if(OK != e) {\n            return _emitError(e);\n        }\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\n        if (ownerIndex == 0) return _emitError(WALLET_UNKNOWN_OWNER);\n        if (m_required > m_numOwners - 1) return _emitError(WALLET_INVALID_INVOCATION);\n\n        m_owners[ownerIndex] = 0;\n        m_ownerIndex[uint(_owner)] = 0;\n        clearPending();\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n        _emitOwnerRemoved(_owner);\n        return OK;\n    }\n\n    function changeRequirement(uint _newRequired) external non2FA returns (uint) {\n        uint e = confirmAndCheck(sha3(msg.data));\n        if(OK != e) {\n            return _emitError(e);\n        }\n        if (_newRequired > m_numOwners) return;\n        m_required = _newRequired;\n        clearPending();\n        _emitRequirementChanged(_newRequired);\n        return OK;\n    }\n\n    // Gets an owner by 0-indexed position (using numOwners as the count)\n    function getOwner(uint ownerIndex) external constant returns (address) {\n        return address(m_owners[ownerIndex + 1]);\n    }\n\n    function isOwner(address _addr) constant returns (bool) {\n        return m_ownerIndex[uint(_addr)] > 0;\n    }\n\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\n        var pending = m_pending[_operation];\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n        // make sure they're an owner\n        if (ownerIndex == 0) return false;\n\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        return !(pending.ownersDone & ownerIndexBit == 0);\n    }\n\n    // INTERNAL METHODS\n\n    function confirmAndCheck(bytes32 _operation) internal returns (uint) {\n        // determine what index the present sender is:\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n        // make sure they're an owner\n        if (ownerIndex == 0) return _emitError(WALLET_UNKNOWN_OWNER);\n\n        var pending = m_pending[_operation];\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\n        if (pending.yetNeeded == 0) {\n            // reset count of confirmations needed.\n            pending.yetNeeded = m_required;\n            // reset which owners have confirmed (none) - set our bitmap to 0.\n            pending.ownersDone = 0;\n            pending.index = m_pendingIndex.length++;\n            m_pendingIndex[pending.index] = _operation;\n        }\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        // make sure we (the message sender) haven't confirmed this operation previously.\n        if (pending.ownersDone & ownerIndexBit == 0) {\n            _emitConfirmation(msg.sender, _operation);\n            // ok - check if count is enough to go ahead.\n            if (pending.yetNeeded <= 1) {\n                // enough confirmations: reset and run interior.\n                delete m_pendingIndex[m_pending[_operation].index];\n                delete m_pending[_operation];\n                return OK;\n            }\n            else\n            {\n                // not enough: record that this owner in particular confirmed.\n                pending.yetNeeded--;\n                pending.ownersDone |= ownerIndexBit;\n                return WALLET_CONFIRMATION_NEEDED;\n            }\n        }\n    }\n\n    function reorganizeOwners() private {\n        uint free = 1;\n        while (free < m_numOwners)\n        {\n            while (free < m_numOwners && m_owners[free] != 0) free++;\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n            {\n                m_owners[free] = m_owners[m_numOwners];\n                m_ownerIndex[m_owners[free]] = free;\n                m_owners[m_numOwners] = 0;\n            }\n        }\n    }\n\n    function toggle2FA() returns (uint) {\n        // determine what index the present sender is and make sure they're an owner\n        if (m_ownerIndex[uint(msg.sender)] == 0) {\n            return _emitError(WALLET_UNKNOWN_OWNER);\n        }\n\n        address walletsManager = ContractsManager(contractsManager).getContractAddressByType(bytes32(\"WalletsManager\"));\n        address oracleAddress = WalletsManagerInterface(walletsManager).getOracleAddress();\n\n        if(oracleAddress == address(0)) {\n            return _emitError(WALLET_INVALID_INVOCATION);\n        }\n\n        if(!use2FA && m_required == 1) {\n            use2FA = true;\n            m_required = 2;\n            clearPending();\n            m_numOwners++;\n            m_owners[m_numOwners] = uint(oracleAddress);\n            m_ownerIndex[uint(oracleAddress)] = m_numOwners;\n            return OK;\n        } else {\n            if(use2FA && m_required == 2 && m_ownerIndex[uint(oracleAddress)] == 1) {\n                use2FA = false;\n                m_required = 1;\n                uint ownerIndex = m_ownerIndex[uint(oracleAddress)];\n                m_owners[ownerIndex] = 0;\n                m_ownerIndex[uint(oracleAddress)] = 0;\n                clearPending();\n                reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n                return OK;\n            }\n        }\n\n        _emit2FAChanged(use2FA);\n    }\n\n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            if (m_pendingIndex[i] != 0)\n                delete m_pending[m_pendingIndex[i]];\n        delete m_pendingIndex;\n    }\n\n    function _emitError(uint errorCode) returns (uint) {\n        Wallet(getEventsHistory()).emitError(errorCode);\n        return errorCode;\n    }\n\n    function _emitDeposit(address from, uint value) {\n        Wallet(getEventsHistory()).emitDeposit(from, value);\n    }\n\n    function _emitSingleTransact(address owner, uint value, address to, bytes32 symbol) {\n        Wallet(getEventsHistory()).emitSingleTransact(owner, value, to, symbol);\n    }\n\n    function _emitMultiTransact(address owner, bytes32 operation, uint value, address to, bytes32 symbol) {\n        Wallet(getEventsHistory()).emitMultiTransact(owner, operation, value, to, symbol);\n    }\n\n    function _emitConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes32 symbol) {\n        Wallet(getEventsHistory()).emitConfirmationNeeded(operation, initiator, value, to, symbol);\n    }\n\n    function _emitConfirmation(address owner, bytes32 operation) {\n        Wallet(getEventsHistory()).emitConfirmation(owner, operation);\n    }\n\n    function _emitRevoke(address owner, bytes32 operation) {\n        Wallet(getEventsHistory()).emitRevoke(owner, operation);\n    }\n\n    function _emitOwnerChanged(address oldOwner, address newOwner) {\n        Wallet(getEventsHistory()).emitOwnerChanged(oldOwner, newOwner);\n    }\n\n    function _emitOwnerAdded(address newOwner) {\n        Wallet(getEventsHistory()).emitOwnerAdded(newOwner);\n    }\n\n    function _emitOwnerRemoved(address oldOwner) {\n        Wallet(getEventsHistory()).emitOwnerAdded(oldOwner);\n    }\n\n    function _emitRequirementChanged(uint newRequirement) {\n        Wallet(getEventsHistory()).emitRequirementChanged(newRequirement);\n    }\n\n    function _emit2FAChanged(bool enabled) {\n        Wallet(getEventsHistory()).emit2FAChanged(enabled);\n    }\n\n   \t// FIELDS\n\n    // wallets use 2FA oracle\n    bool public use2FA;\n\n    // the number of owners that must confirm the same operation before it is run.\n    uint public m_required;\n    // pointer used to find a free slot in m_owners\n    uint public m_numOwners;\n\n    uint public version;\n\n    // list of owners\n    uint[256] m_owners;\n    uint constant c_maxOwners = 250;\n    uint constant c_maxPending = 20;\n    // index on the list of owners to allow reverse lookup\n    mapping(uint => uint) m_ownerIndex;\n    // the ongoing operations.\n    mapping(bytes32 => PendingState) m_pending;\n    bytes32[] m_pendingIndex;\n}\n\n// usage:\n// bytes32 h = Wallet(w).from(oneOwner).execute(to, value, data);\n// Wallet(w).from(anotherOwner).confirm(h);\ncontract Wallet is multiowned {\n\n    // TYPES\n\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\n    struct Transaction {\n        address to;\n        uint value;\n        bytes32 symbol;\n    }\n\n    // METHODS\n\n    // constructor - just pass on the owner array to the multiowned and\n    // the limit to daylimit\n    function Wallet(address[] _owners, uint _required, address _contractsManager, address _eventsHistory, bool _use2FA, uint _releaseTime) multiowned(_owners, _required)  {\n        contractsManager = _contractsManager;\n        eventsEmmiter = _eventsHistory;\n        use2FA = _use2FA;\n        releaseTime = _releaseTime;\n    }\n\n    function getTokenAddresses() constant returns (address[] result) {\n        address erc20Manager = ContractsManager(contractsManager).getContractAddressByType(bytes32(\"ERC20Manager\"));\n        uint counter = ERC20Manager(erc20Manager).tokensCount();\n        result = new address[](counter);\n        for(uint i=0;i<counter;i++) {\n            result[i] = ERC20Manager(erc20Manager).getAddressById(i);\n        }\n        return result;\n    }\n\n    function getPendings()\n    public\n    constant\n    returns (address[] result1, uint[] result2, bytes32[] result3, bytes32[] operations, bool[] isConfirmed)\n    {\n        result1 = new address[](m_pendingIndex.length);\n        result2 = new uint[](m_pendingIndex.length);\n        result3 = new bytes32[](m_pendingIndex.length);\n        operations = new bytes32[](m_pendingIndex.length);\n        isConfirmed = new bool[](m_pendingIndex.length);\n        for(uint i=0;i<m_pendingIndex.length;i++) {\n            result1[i] = m_txs[m_pendingIndex[i]].to;\n            result2[i] = m_txs[m_pendingIndex[i]].value;\n            result3[i] = m_txs[m_pendingIndex[i]].symbol;\n            operations[i] = m_pendingIndex[i];\n            isConfirmed[i] = hasConfirmed(m_pendingIndex[i], msg.sender);\n        }\n        return (result1, result2, result3, operations, isConfirmed);\n    }\n\n    // kills the contract sending everything to `_to`.\n    function kill(address _to) external returns (uint) {\n        if(releaseTime > now) {\n            return _emitError(WALLET_RELEASE_TIME_ERROR);\n        }\n        uint e = confirmAndCheck(sha3(msg.data));\n        if(OK != e) {\n            return _emitError(e);\n        }\n        address[] memory tokens = getTokenAddresses();\n        for(uint i=0;i<tokens.length;i++) {\n            address token = tokens[i];\n            uint balance = ERC20Interface(token).balanceOf(this);\n            if(balance != 0)\n            ERC20Interface(token).transfer(_to,balance);\n        }\n        selfdestruct(_to);\n        address walletsManager = ContractsManager(contractsManager).getContractAddressByType(bytes32(\"WalletsManager\"));\n        return WalletsManagerInterface(walletsManager).removeWallet();\n\n    }\n\n    // gets called when no other function matches\n    function() payable {\n        // just being sent some cash?\n        if (msg.value > 0)\n            _emitDeposit(msg.sender, msg.value);\n    }\n\n    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n    // and _data arguments). They still get the option of using them if they want, anyways.\n    function transfer(address _to, uint _value, bytes32 _symbol) payable returns (uint) {\n        if(!isOwner(msg.sender)) {\n            return _emitError(WALLET_UNKNOWN_OWNER);\n        }\n        if(releaseTime > now) {\n            return _emitError(WALLET_RELEASE_TIME_ERROR);\n        }\n        if(use2FA) {\n            address walletsManager = ContractsManager(contractsManager).getContractAddressByType(bytes32(\"WalletsManager\"));\n            uint oraclePrice = WalletsManagerInterface(walletsManager).getOraclePrice();\n            address oracleAddress = WalletsManagerInterface(walletsManager).getOracleAddress();\n            if(oraclePrice == 0 || oracleAddress == address(0)) {\n                return _emitError(WALLET_INVALID_INVOCATION);\n            }\n            if(msg.value < oraclePrice) {\n                return _emitError(WALLET_INVALID_INVOCATION);\n            }\n            if(!oracleAddress.send(msg.value)) {\n                return _emitError(WALLET_INVALID_INVOCATION);\n            }\n        }\n        if(_symbol == bytes32('ETH') || _symbol == bytes32(0)) {\n            if(this.balance < _value) {\n                return _emitError(WALLET_INSUFFICIENT_BALANCE);\n            }\n        } else {\n            address erc20Manager = ContractsManager(contractsManager).getContractAddressByType(bytes32(\"ERC20Manager\"));\n            if(ERC20Manager(erc20Manager).getTokenAddressBySymbol(_symbol) == 0)\n            return _emitError(WALLET_UNKNOWN_TOKEN_TRANSFER);\n            else {\n                address token = ERC20Manager(erc20Manager).getTokenAddressBySymbol(_symbol);\n                if(ERC20Interface(token).balanceOf(this) < _value)\n                return _emitError(WALLET_INSUFFICIENT_BALANCE);\n            }\n        }\n        // determine our operation hash.\n        bytes32 _r = sha3(msg.data, now);\n        if (m_txs[_r].to == 0) {\n            m_txs[_r].to = _to;\n            m_txs[_r].value = _value;\n            m_txs[_r].symbol = _symbol;\n            _emitConfirmationNeeded(_r, msg.sender, _value, _to, _symbol);\n            uint status = confirm(_r);\n            return status;\n        }\n        return _emitError(WALLET_TRANSFER_ALREADY_REGISTERED);\n    }\n\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n    // to determine the body of the transaction from the hash provided.\n    function confirm(bytes32 _h) returns (uint) {\n        uint e = confirmAndCheck(_h);\n        if(OK != e) {\n            return e;\n        }\n        if (m_txs[_h].to != 0) {\n            if(m_txs[_h].symbol == bytes32('ETH')) {\n                require(m_txs[_h].to.send(m_txs[_h].value));\n            }\n            else {\n                address erc20Manager = ContractsManager(contractsManager).getContractAddressByType(bytes32(\"ERC20Manager\"));\n                address token = ERC20Manager(erc20Manager).getTokenAddressBySymbol(m_txs[_h].symbol);\n                ERC20Interface(token).transfer(m_txs[_h].to,m_txs[_h].value);\n            }\n            _emitMultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].symbol);\n            delete m_txs[_h];\n            return OK;\n        }\n        return _emitError(WALLET_INVALID_INVOCATION);\n    }\n\n    // INTERNAL METHODS\n\n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            delete m_txs[m_pendingIndex[i]];\n        super.clearPending();\n    }\n\n\t// FIELDS\n\n    // pending transactions we have at present.\n    mapping (bytes32 => Transaction) m_txs;\n    uint public releaseTime;\n}\n","abiDocs":[{"constant":false,"inputs":[{"name":"errorCode","type":"uint256"}],"name":"_emitError","payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitError(uint256)","signatureHash":"06d44278"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"_emitSingleTransact","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitSingleTransact(address,uint256,address,bytes32)","signatureHash":"0bcfdf47"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"emitOwnerAdded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitOwnerAdded(address)","signatureHash":"11673db9"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"}],"name":"emitConfirmation","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitConfirmation(address,bytes32)","signatureHash":"14da0797"},{"constant":false,"inputs":[{"name":"_owner","type":"address"}],"name":"removeOwner","payable":false,"stateMutability":"nonpayable","type":"function","signature":"removeOwner(address)","signatureHash":"173825d9"},{"constant":false,"inputs":[{"name":"from","type":"address"},{"name":"value","type":"uint256"}],"name":"emitDeposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitDeposit(address,uint256)","signatureHash":"28ba84ca"},{"constant":true,"inputs":[{"name":"_addr","type":"address"}],"name":"isOwner","payable":false,"stateMutability":"view","type":"function","signature":"isOwner(address)","signatureHash":"2f54bf6e"},{"constant":false,"inputs":[],"name":"toggle2FA","payable":false,"stateMutability":"nonpayable","type":"function","signature":"toggle2FA()","signatureHash":"3311f99a"},{"constant":true,"inputs":[],"name":"m_numOwners","payable":false,"stateMutability":"view","type":"function","signature":"m_numOwners()","signatureHash":"4123cb6b"},{"constant":false,"inputs":[{"name":"newRequirement","type":"uint256"}],"name":"emitRequirementChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitRequirementChanged(uint256)","signatureHash":"418cbda9"},{"constant":false,"inputs":[{"name":"enabled","type":"bool"}],"name":"emit2FAChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emit2FAChanged(bool)","signatureHash":"4367f19a"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"emitMultiTransact","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitMultiTransact(address,bytes32,uint256,address,bytes32)","signatureHash":"4f39cb53"},{"constant":true,"inputs":[],"name":"version","payable":false,"stateMutability":"view","type":"function","signature":"version()","signatureHash":"54fd4d50"},{"constant":false,"inputs":[{"name":"operation","type":"bytes32"},{"name":"initiator","type":"address"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"_emitConfirmationNeeded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitConfirmationNeeded(bytes32,address,uint256,address,bytes32)","signatureHash":"557027ba"},{"constant":false,"inputs":[{"name":"oldOwner","type":"address"},{"name":"newOwner","type":"address"}],"name":"emitOwnerChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitOwnerChanged(address,address)","signatureHash":"5b0b6f66"},{"constant":false,"inputs":[{"name":"oldOwner","type":"address"}],"name":"emitOwnerRemoved","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitOwnerRemoved(address)","signatureHash":"660918ca"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"}],"name":"_emitConfirmation","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitConfirmation(address,bytes32)","signatureHash":"6c004411"},{"constant":false,"inputs":[{"name":"_owner","type":"address"}],"name":"addOwner","payable":false,"stateMutability":"nonpayable","type":"function","signature":"addOwner(address)","signatureHash":"7065cb48"},{"constant":true,"inputs":[],"name":"m_required","payable":false,"stateMutability":"view","type":"function","signature":"m_required()","signatureHash":"746c9171"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"emitSingleTransact","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitSingleTransact(address,uint256,address,bytes32)","signatureHash":"76583f66"},{"constant":false,"inputs":[{"name":"oldOwner","type":"address"}],"name":"_emitOwnerRemoved","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitOwnerRemoved(address)","signatureHash":"90606e30"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"}],"name":"_emitRevoke","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitRevoke(address,bytes32)","signatureHash":"93b50d98"},{"constant":true,"inputs":[],"name":"use2FA","payable":false,"stateMutability":"view","type":"function","signature":"use2FA()","signatureHash":"9d2a43ad"},{"constant":false,"inputs":[{"name":"enabled","type":"bool"}],"name":"_emit2FAChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emit2FAChanged(bool)","signatureHash":"b6e4c5bf"},{"constant":false,"inputs":[{"name":"_operation","type":"bytes32"}],"name":"revoke","payable":false,"stateMutability":"nonpayable","type":"function","signature":"revoke(bytes32)","signatureHash":"b75c7dc6"},{"constant":false,"inputs":[{"name":"_newRequired","type":"uint256"}],"name":"changeRequirement","payable":false,"stateMutability":"nonpayable","type":"function","signature":"changeRequirement(uint256)","signatureHash":"ba51a6df"},{"constant":false,"inputs":[{"name":"newRequirement","type":"uint256"}],"name":"_emitRequirementChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitRequirementChanged(uint256)","signatureHash":"babdd811"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"_emitOwnerAdded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitOwnerAdded(address)","signatureHash":"c28d11ca"},{"constant":true,"inputs":[{"name":"_operation","type":"bytes32"},{"name":"_owner","type":"address"}],"name":"hasConfirmed","payable":false,"stateMutability":"view","type":"function","signature":"hasConfirmed(bytes32,address)","signatureHash":"c2cf7326"},{"constant":true,"inputs":[{"name":"ownerIndex","type":"uint256"}],"name":"getOwner","payable":false,"stateMutability":"view","type":"function","signature":"getOwner(uint256)","signatureHash":"c41a360a"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"}],"name":"emitRevoke","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitRevoke(address,bytes32)","signatureHash":"d4554737"},{"constant":false,"inputs":[{"name":"oldOwner","type":"address"},{"name":"newOwner","type":"address"}],"name":"_emitOwnerChanged","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitOwnerChanged(address,address)","signatureHash":"d5b3c27a"},{"constant":false,"inputs":[{"name":"errorCode","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitError(uint256)","signatureHash":"df26ca08"},{"constant":false,"inputs":[{"name":"from","type":"address"},{"name":"value","type":"uint256"}],"name":"_emitDeposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitDeposit(address,uint256)","signatureHash":"e037fc90"},{"constant":false,"inputs":[{"name":"operation","type":"bytes32"},{"name":"initiator","type":"address"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"emitConfirmationNeeded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitConfirmationNeeded(bytes32,address,uint256,address,bytes32)","signatureHash":"eb559c14"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"}],"name":"changeOwner","payable":false,"stateMutability":"nonpayable","type":"function","signature":"changeOwner(address,address)","signatureHash":"f00d4b5d"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"operation","type":"bytes32"},{"name":"value","type":"uint256"},{"name":"to","type":"address"},{"name":"symbol","type":"bytes32"}],"name":"_emitMultiTransact","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitMultiTransact(address,bytes32,uint256,address,bytes32)","signatureHash":"ff55ed6d"},{"constant":true,"inputs":[],"name":"getEventsHistory","payable":false,"stateMutability":"view","type":"function","signature":"getEventsHistory()","signatureHash":"fff10aba"},{"inputs":[{"name":"_owners","type":"address[]"},{"name":"_required","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"from","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"MultisigWalletDeposit","type":"event","signature":"MultisigWalletDeposit(address,address,uint256)","signatureHash":"bee6d297"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"to","type":"address"},{"indexed":false,"name":"symbol","type":"bytes32"}],"name":"MultisigWalletSingleTransact","type":"event","signature":"MultisigWalletSingleTransact(address,address,uint256,address,bytes32)","signatureHash":"113341d7"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"operation","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"to","type":"address"},{"indexed":false,"name":"symbol","type":"bytes32"}],"name":"MultisigWalletMultiTransact","type":"event","signature":"MultisigWalletMultiTransact(address,address,bytes32,uint256,address,bytes32)","signatureHash":"ec604b4a"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"operation","type":"bytes32"},{"indexed":true,"name":"initiator","type":"address"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"to","type":"address"},{"indexed":false,"name":"symbol","type":"bytes32"}],"name":"MultisigWalletConfirmationNeeded","type":"event","signature":"MultisigWalletConfirmationNeeded(address,bytes32,address,uint256,address,bytes32)","signatureHash":"99650330"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"operation","type":"bytes32"}],"name":"MultisigWalletConfirmation","type":"event","signature":"MultisigWalletConfirmation(address,address,bytes32)","signatureHash":"619980af"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"operation","type":"bytes32"}],"name":"MultisigWalletRevoke","type":"event","signature":"MultisigWalletRevoke(address,address,bytes32)","signatureHash":"19488fab"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"oldOwner","type":"address"},{"indexed":true,"name":"newOwner","type":"address"}],"name":"MultisigWalletOwnerChanged","type":"event","signature":"MultisigWalletOwnerChanged(address,address,address)","signatureHash":"f326492b"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"newOwner","type":"address"}],"name":"MultisigWalletOwnerAdded","type":"event","signature":"MultisigWalletOwnerAdded(address,address)","signatureHash":"fda76996"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":true,"name":"oldOwner","type":"address"}],"name":"MultisigWalletOwnerRemoved","type":"event","signature":"MultisigWalletOwnerRemoved(address,address)","signatureHash":"00d0db01"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"newRequirement","type":"uint256"}],"name":"MultisigWalletRequirementChanged","type":"event","signature":"MultisigWalletRequirementChanged(address,uint256)","signatureHash":"b26123db"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"enabled","type":"bool"}],"name":"MultisigWallet2FAChanged","type":"event","signature":"MultisigWallet2FAChanged(address,bool)","signatureHash":"3c05c875"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event","signature":"Error(address,uint256)","signatureHash":"9cf38cf2"}]}
