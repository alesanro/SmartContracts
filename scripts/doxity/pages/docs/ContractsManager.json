{"title":"ContractsManager","fileName":"/contracts/core/contracts/ContractsManager.sol","name":"ContractsManager","abi":[{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"pendingContractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getContractAddresses","outputs":[{"name":"","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_contract","type":"address"},{"name":"_type","type":"bytes32"}],"name":"addContract","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_type","type":"bytes32"}],"name":"getContractAddressByType","outputs":[{"name":"contractAddress","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_contract","type":"address"}],"name":"removeContract","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"contractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_contract","type":"address"}],"name":"isExists","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":true,"name":"contractAddress","type":"address"},{"indexed":false,"name":"t","type":"bytes32"}],"name":"LogAddContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"contractAddress","type":"address"},{"indexed":false,"name":"t","type":"bytes32"}],"name":"LogContractAddressChange","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event"}],"source":"pragma solidity ^0.4.11;\n\nimport \"../common/Object.sol\";\nimport \"../storage/StorageAdapter.sol\";\nimport \"../common/OwnedInterface.sol\";\nimport \"./ContractsManagerInterface.sol\";\n\n/**\n*  @title ContractsManager\n*/\ncontract ContractsManager is Object, StorageAdapter, ContractsManagerInterface {\n    uint constant ERROR_CONTRACT_EXISTS = 10000;\n    uint constant ERROR_CONTRACT_NOT_EXISTS = 10001;\n\n    StorageInterface.AddressesSet contractsAddresses;\n    StorageInterface.Bytes32AddressMapping contractsTypes;\n\n    event LogAddContract(address indexed contractAddress, bytes32 t);\n    event LogContractAddressChange(address indexed contractAddress, bytes32 t);\n    event Error(address indexed self, uint errorCode);\n\n    /**\n    *  @notice Constructor that sets `storage` and `crate` to given values.\n    */\n    function ContractsManager(Storage _store, bytes32 _crate) StorageAdapter(_store, _crate) {\n        contractsAddresses.init('contracts');\n        contractsTypes.init('contractTypes');\n    }\n\n    /**\n    *   @dev Returns an array containing all contracts addresses.\n    *   @return Array of token addresses.\n    */\n    function getContractAddresses() constant returns (address[]) {\n        return store.get(contractsAddresses);\n    }\n\n    /**\n    *   @dev Returns a contracts address by given type.\n    *   @return contractAddress\n    */\n    function getContractAddressByType(bytes32 _type) constant returns (address contractAddress) {\n        return store.get(contractsTypes, _type);\n    }\n\n    /**\n    *  @dev Allow owner to add new contract\n    *\n    *  @param _contract contacts address\n    *  @param _type contracts type\n    *\n    *  @return result code, 1 if success, otherwise error code\n    */\n    function addContract(address _contract, bytes32 _type) onlyAllowed() returns (uint) {\n        if (isExists(_contract)) {\n            return emitError(ERROR_CONTRACT_EXISTS);\n        }\n\n        if (store.get(contractsTypes, _type) == 0x0) {\n            store.add(contractsAddresses, _contract);\n        } else {\n            store.set(contractsAddresses, store.get(contractsTypes, _type), _contract);\n        }\n\n        store.set(contractsTypes, _type, _contract);\n\n        LogAddContract(_contract, _type);\n        return OK;\n    }\n\n    /**\n    *  @dev Allow owner to add new contract\n    *\n    *  @param _contract contacts address\n    *\n    *  @return result code, 1 if success, otherwise error code\n    */\n    function removeContract(address _contract) onlyAllowed() returns (uint) {\n        if (!isExists(_contract)) {\n            return emitError(ERROR_CONTRACT_NOT_EXISTS);\n        }\n\n        store.remove(contractsAddresses, _contract);\n        //store.set(contractsTypes, _type, 0x0); TODO: ahiatsevich: remove type\n\n        return OK;\n    }\n\n    /**\n    *  @dev Tells whether a contract wit a given address exists.\n    *\n    *  @return `true` if a contract has been registers, otherwise `false`\n    */\n    function isExists(address _contract) constant returns (bool) {\n        return store.includes(contractsAddresses, _contract);\n    }\n\n    /**\n    *  @dev Util function which throws error event with a given error\n    */\n    function emitError(uint e) private returns (uint)  {\n        Error(msg.sender, e);\n        return e;\n    }\n\n    /**\n    *  @return true if `caller` is  a contact owner or authorized to make changes in Storage\n    */\n    modifier onlyAllowed() {\n        if (contractOwner == msg.sender ||\n                store.store.manager().hasAccess(msg.sender)) {\n            _;\n        }\n    }\n\n    /**\n    *  Default fallback function.\n    */\n    function() {\n        throw;\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Finalize ownership pass.     * Can only be called by pending owner.","signature":"claimContractOwnership()","signatureHash":"4592cd1d"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"address of the next owner. 0x0 is not allowed."}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Prepares ownership pass.     * Can only be called by current owner.","signature":"changeContractOwnership(address)","signatureHash":"557f4bc9"},{"constant":true,"inputs":[],"name":"pendingContractOwner","payable":false,"stateMutability":"view","type":"function","signature":"pendingContractOwner()","signatureHash":"5aa77d3c"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Destroy contract and scrub a data","notice":"Only owner can call it","signature":"destroy()","signatureHash":"83197ef0"},{"constant":true,"inputs":[],"name":"getContractAddresses","outputs":[{"name":"","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function","details":"Returns an array containing all contracts addresses.","return":"Array of token addresses.","signature":"getContractAddresses()","signatureHash":"953874d2"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"the next contract owner"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Direct ownership pass without change/claim pattern. Can be invoked only by current contract owner","return":"`true` if success, `false` otherwise","signature":"transferContractOwnership(address)","signatureHash":"a843c51f"},{"constant":false,"inputs":[{"name":"_contract","type":"address","description":"contacts address"},{"name":"_type","type":"bytes32","description":"contracts type"}],"name":"addContract","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Allow owner to add new contract","return":"result code, 1 if success, otherwise error code","signature":"addContract(address,bytes32)","signatureHash":"b7c46cd5"},{"constant":true,"inputs":[{"name":"_type","type":"bytes32"}],"name":"getContractAddressByType","outputs":[{"name":"contractAddress","type":"address","description":""}],"payable":false,"stateMutability":"view","type":"function","details":"Returns a contracts address by given type.","return":"contractAddress","signature":"getContractAddressByType(bytes32)","signatureHash":"bc657927"},{"constant":false,"inputs":[{"name":"_contract","type":"address","description":"contacts address"}],"name":"removeContract","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Allow owner to add new contract","return":"result code, 1 if success, otherwise error code","signature":"removeContract(address)","signatureHash":"c375c2ef"},{"constant":true,"inputs":[],"name":"contractOwner","payable":false,"stateMutability":"view","type":"function","signature":"contractOwner()","signatureHash":"ce606ee0"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","payable":false,"stateMutability":"nonpayable","type":"function","signature":"withdrawnTokens(address[],address)","signatureHash":"d8f9659b"},{"constant":true,"inputs":[{"name":"_contract","type":"address"}],"name":"isExists","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","details":"Tells whether a contract wit a given address exists.","return":"`true` if a contract has been registers, otherwise `false`","signature":"isExists(address)","signatureHash":"e0d4f1c3"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback","inputs":[]},{"anonymous":false,"inputs":[{"indexed":true,"name":"contractAddress","type":"address"},{"indexed":false,"name":"t","type":"bytes32"}],"name":"LogAddContract","type":"event","signature":"LogAddContract(address,bytes32)","signatureHash":"78d9711b"},{"anonymous":false,"inputs":[{"indexed":true,"name":"contractAddress","type":"address"},{"indexed":false,"name":"t","type":"bytes32"}],"name":"LogContractAddressChange","type":"event","signature":"LogContractAddressChange(address,bytes32)","signatureHash":"7f67b774"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event","signature":"Error(address,uint256)","signatureHash":"9cf38cf2"}]}
