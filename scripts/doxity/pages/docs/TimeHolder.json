{"fileName":"/contracts/timeholder/TimeHolder.sol","name":"TimeHolder","abi":[{"constant":false,"inputs":[{"name":"who","type":"address"},{"name":"amount","type":"uint256"}],"name":"emitWithdrawShares","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"},{"name":"_sharesContract","type":"address"},{"name":"_wallet","type":"address"},{"name":"_feeWallet","type":"address"}],"name":"init","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"shareholdersCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_amount","type":"uint256"}],"name":"withdrawShares","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"listener","type":"address"}],"name":"emitListenerRemoved","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_limitAmount","type":"uint256"}],"name":"setLimit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"who","type":"address"},{"name":"amount","type":"uint256"}],"name":"emitDeposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_address","type":"address"},{"name":"_amount","type":"uint256"}],"name":"depositFor","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"listener","type":"address"}],"name":"emitListenerAdded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalShares","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32"}],"name":"lookupManager","outputs":[{"name":"manager","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"wallet","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"contractsManager","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"pendingContractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"sharesContract","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_feeWallet","type":"address"}],"name":"setFeeWallet","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_address","type":"address"}],"name":"depositBalance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_amount","type":"uint256"}],"name":"emitFeatureFeeTaken","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_listener","type":"address"}],"name":"removeListener","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getLimit","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_amount","type":"uint256"}],"name":"deposit","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"contractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_listener","type":"address"}],"name":"addListener","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"error","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_account","type":"address"},{"name":"_amount","type":"uint256"}],"name":"takeFeatureFee","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"feeWallet","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getEventsHistory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":false,"name":"who","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"who","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"WithdrawShares","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"listener","type":"address"}],"name":"ListenerAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"listener","type":"address"}],"name":"ListenerRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"self","type":"address"},{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"FeatureFeeTaken","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event"}],"source":"pragma solidity ^0.4.11;\n\nimport \"./TimeHolderEmmiter.sol\";\nimport \"../core/common/BaseManager.sol\";\nimport \"../core/common/ListenerInterface.sol\";\nimport \"../core/common/Deposits.sol\";\nimport {ERC20Interface as Asset} from \"../core/erc20/ERC20Interface.sol\";\nimport \"./DepositWalletInterface.sol\";\n\ncontract TimeHolder is Deposits, TimeHolderEmmiter {\n\n    uint constant ERROR_TIMEHOLDER_ALREADY_ADDED = 12000;\n    uint constant ERROR_TIMEHOLDER_INVALID_INVOCATION = 12001;\n    uint constant ERROR_TIMEHOLDER_INVALID_STATE = 12002;\n    uint constant ERROR_TIMEHOLDER_TRANSFER_FAILED = 12003;\n    uint constant ERROR_TIMEHOLDER_WITHDRAWN_FAILED = 12004;\n    uint constant ERROR_TIMEHOLDER_DEPOSIT_FAILED = 12005;\n    uint constant ERROR_TIMEHOLDER_INSUFFICIENT_BALANCE = 12006;\n    uint constant ERROR_TIMEHOLDER_LIMIT_EXCEEDED = 12007;\n\n    StorageInterface.OrderedAddressesSet listeners;\n    StorageInterface.Address walletStorage;\n    StorageInterface.Address feeWalletStorage;\n    StorageInterface.UInt limitAmount;\n\n    modifier onlyFeatureFeeManager() {\n        if (msg.sender == lookupManager(\"FeatureFeeManager\")) {\n            _;\n        }\n    }\n\n    function TimeHolder(Storage _store, bytes32 _crate) Deposits(_store, _crate) {\n        listeners.init('listeners');\n        limitAmount.init('limitAmount');\n        feeWalletStorage.init(\"timeHolderFeeWalletStorage\");\n        walletStorage.init(\"timeHolderWalletStorage\");\n    }\n\n    /**\n     * Init TimeHolder contract.\n     *\n     *\n     * @param _contractsManager address.\n     * @param _sharesContract ERC20 token address to act as shares.\n     *\n     * @return success.\n     */\n    function init(address _contractsManager, address _sharesContract, address _wallet, address _feeWallet) onlyContractOwner returns (uint) {\n        require(_wallet != 0x0);\n        require(_sharesContract != 0x0);\n        require(_feeWallet != 0x0);\n\n        BaseManager.init(_contractsManager, \"TimeHolder\");\n\n        store.set(sharesContractStorage, _sharesContract);\n        store.set(limitAmount, 2**255);\n        store.set(walletStorage, _wallet);\n        store.set(feeWalletStorage, _feeWallet);\n\n        return OK;\n    }\n\n    function destroy() onlyContractOwner {\n        selfdestruct(msg.sender);\n    }\n\n    function addListener(address _listener) onlyAuthorized returns (uint) {\n        //if(store.includes(listeners,_listener) || !_listener.call.gas(3000).value(0)(bytes4(sha3(\"deposit(address,uint256,uint256)\")),this,0,0) || !_listener.call.gas(3000).value(0)(bytes4(sha3(\"withdrawn(address,uint256,uint256)\")),this,0,0)) {\n        //    return _emitError(ERROR_TIMEHOLDER_INVALID_INVOCATION);\n        //}\n        ListenerInterface(_listener).deposit(this,0,0);\n        ListenerInterface(_listener).withdrawn(this,0,0);\n        if(store.includes(listeners,_listener)) {\n            return _emitError( ERROR_TIMEHOLDER_ALREADY_ADDED);\n        }\n\n        store.add(listeners,_listener);\n\n        _emitListenerAdded(_listener);\n\n        return OK;\n    }\n\n    /**\n    *  Sets fee wallet address.\n    */\n    function setFeeWallet(address _feeWallet) onlyContractOwner {\n        require(_feeWallet != 0x0);\n        store.set(feeWalletStorage, _feeWallet);\n    }\n\n    function removeListener(address _listener) onlyAuthorized {\n        if (store.includes(listeners, _listener)) {\n            store.remove(listeners, _listener);\n            _emitListenerRemoved(_listener);\n        }\n    }\n\n    /**\n    * Gets an associated wallet for the time holder\n    */\n    function wallet() constant returns (address) {\n        return store.get(walletStorage);\n    }\n\n    /**\n    * Gets an associated fee wallet for the time holder\n    */\n    function feeWallet() constant returns (address) {\n        return store.get(feeWalletStorage);\n    }\n\n    /**\n    * Total amount of shares\n    *\n    * @return total amount of shares\n    */\n    function totalShares() constant returns (uint) {\n        return store.get(totalSharesStorage);\n    }\n\n    /**\n    * Contract address of shares\n    *\n    * @return address of shares contract\n    */\n    function sharesContract() constant returns (address) {\n        return store.get(sharesContractStorage);\n    }\n\n    /**\n    * Number of shareholders\n    *\n    * @return number of shareholders\n    */\n    function shareholdersCount() constant returns (uint) {\n        return store.count(shareholders);\n    }\n\n    /**\n    * Returns deposit/withdraw limit\n    *\n    * @return limit\n    */\n    function getLimit() constant returns (uint) {\n        return store.get(limitAmount);\n    }\n\n    /**\n    * Setter deposit/withdraw limit\n    *\n    * @param _limitAmount is limit\n    */\n    function setLimit(uint _limitAmount) onlyContractOwner {\n        store.set(limitAmount, _limitAmount);\n    }\n\n    /**\n     * Deposit shares and prove possession.\n     * Amount should be less than or equal to current allowance value.\n     *\n     * Proof should be repeated for each active period. To prove possesion without\n     * depositing more shares, specify 0 amount.\n     *\n     * @param _amount amount of shares to deposit, or 0 to just prove.\n     *\n     * @return success.\n     */\n    function deposit(uint _amount) returns (uint) {\n        return depositFor(msg.sender, _amount);\n    }\n\n    /**\n     * Deposit own shares and prove possession for arbitrary shareholder.\n     * Amount should be less than or equal to caller current allowance value.\n     *\n     * Proof should be repeated for each active period. To prove possesion without\n     * depositing more shares, specify 0 amount.\n     *\n     * This function meant to be used by some backend application to prove shares possesion\n     * of arbitrary shareholders.\n     *\n     * @param _address to deposit and prove for.\n     * @param _amount amount of shares to deposit, or 0 to just prove.\n     *\n     * @return success.\n     */\n    function depositFor(address _address, uint _amount) returns (uint) {\n        if (_amount > getLimit()) {\n            return _emitError(ERROR_TIMEHOLDER_LIMIT_EXCEEDED);\n        }\n\n        address asset = store.get(sharesContractStorage);\n        if (!(_amount == 0 || DepositWalletInterface(wallet()).deposit(asset, msg.sender, _amount))) {\n            return _emitError(ERROR_TIMEHOLDER_TRANSFER_FAILED);\n        }\n\n        if(!store.includes(shareholders,_address)) {\n            store.add(shareholders,_address);\n        }\n\n        uint prevId = store.get(depositsIdCounter);\n        uint id = prevId + 1;\n        store.set(depositsIdCounter, id);\n        store.add(deposits,bytes32(_address),id);\n        store.set(amounts,_address,id,_amount);\n        store.set(timestamps,_address,id,now);\n\n        uint balance = depositBalance(_address);\n        uint errorCode;\n        StorageInterface.Iterator memory iterator = store.listIterator(listeners);\n        for(uint i = 0; store.canGetNextWithIterator(listeners,iterator); i++) {\n            address listener = store.getNextWithIterator(listeners,iterator);\n            errorCode = ListenerInterface(listener).deposit(_address, _amount, balance);\n            if (OK != errorCode) {\n                _emitError(errorCode);\n            }\n        }\n\n        _emitDeposit(_address, _amount);\n\n        uint prevAmount = store.get(totalSharesStorage);\n        _amount += prevAmount;\n        store.set(totalSharesStorage,_amount);\n\n        return OK;\n    }\n\n    /**\n    * Withdraw shares from the contract, updating the possesion proof in active period.\n    *\n    * @param _amount amount of shares to withdraw.\n    *\n    * @return success.\n    */\n    function withdrawShares(uint _amount) returns (uint resultCode) {\n        resultCode = _withdrawShares(msg.sender, msg.sender, _amount);\n        if (resultCode != OK) {\n            return _emitError(resultCode);\n        }\n\n        _emitWithdrawShares(msg.sender, _amount);\n    }\n\n    /**\n    * @dev Provides a way to support getting additional fee for using features of the system.\n    *\n    * @param _account holder of deposits, will pay for using a features\n    * @param _amount size of a fee\n    *\n    * @return resultCode result code of the operation\n    */\n    function takeFeatureFee(address _account, uint _amount) onlyFeatureFeeManager\n    public returns (uint resultCode)\n    {\n        require(_account != 0x0);\n\n        assert(feeWallet() != 0x0);\n\n        resultCode = _withdrawShares(_account, feeWallet(), _amount);\n        if (resultCode != OK) {\n            return _emitError(resultCode);\n        }\n\n        _emitFeatureFeeTaken(_account, feeWallet(), _amount);\n    }\n\n    /**\n    * @dev Withdraws deposited amount of tokens from account to a receiver address.\n    * Emits its own errorCodes if some will be encountered.\n    *\n    * @param _account an address that have deposited tokens\n    * @param _receiver an address that will receive tokens from _account\n    * @param _amount amount of tokens to withdraw to the _receiver\n    *\n    * @return result code of the operation\n    */\n    function _withdrawShares(address _account, address _receiver, uint _amount) internal returns (uint) {\n        if (_amount > getLimit()) {\n            return _emitError(ERROR_TIMEHOLDER_LIMIT_EXCEEDED);\n        }\n\n        if (_amount > depositBalance(_account)) {\n            return _emitError(ERROR_TIMEHOLDER_INSUFFICIENT_BALANCE);\n        }\n\n        if (!DepositWalletInterface(wallet()).withdraw(sharesContract(), _receiver, _amount)) {\n            return _emitError(ERROR_TIMEHOLDER_TRANSFER_FAILED);\n        }\n\n        uint _original_amount = _amount;\n        uint i;\n\n        StorageInterface.Iterator memory iterator;\n\n        if (depositBalance(_account) != 0) {\n            iterator = store.listIterator(deposits, bytes32(_account));\n            uint deposits_count = iterator.count();\n            if (deposits_count != 0) {\n                for (i = 0; store.canGetNextWithIterator(deposits,iterator); i++) {\n                    uint _id = store.getNextWithIterator(deposits,iterator);\n                    uint _cur_amount = store.get(amounts, _account, _id);\n                    if (_amount < _cur_amount) {\n                        store.set(amounts, _account, _id, _cur_amount - _amount);\n                        break;\n                    }\n                    if (_amount == _cur_amount) {\n                        store.remove(deposits, bytes32(_account), _id);\n                        deposits_count--;\n                        break;\n                    }\n                    if (_amount > _cur_amount) {\n                        _amount -= _cur_amount;\n                        store.remove(deposits, bytes32(_account), _id);\n                        deposits_count--;\n                    }\n                }\n            }\n            if (deposits_count == 0) {\n                store.remove(shareholders, _account);\n            }\n        }\n\n        uint errorCode;\n        uint balance = depositBalance(_account);\n\n        iterator = store.listIterator(listeners);\n        for (i = 0; store.canGetNextWithIterator(listeners,iterator); i++) {\n            address listener = store.getNextWithIterator(listeners, iterator);\n            errorCode = ListenerInterface(listener).withdrawn(_account, _original_amount, balance);\n            if (errorCode != OK) {\n                _emitError(errorCode);\n            }\n        }\n\n        store.set(totalSharesStorage,store.get(totalSharesStorage) - _original_amount);\n\n        return OK;\n    }\n\n    function totalSupply() constant returns (uint) {\n        address asset = store.get(sharesContractStorage);\n        return ERC20Interface(asset).totalSupply();\n    }\n\n    function _emitDeposit(address who, uint amount) private {\n        TimeHolder(getEventsHistory()).emitDeposit(who, amount);\n    }\n\n    function _emitWithdrawShares(address who, uint amount) private {\n        TimeHolder(getEventsHistory()).emitWithdrawShares(who, amount);\n    }\n\n    function _emitListenerAdded(address listener) private {\n        TimeHolder(getEventsHistory()).emitListenerAdded(listener);\n    }\n\n    function _emitListenerRemoved(address listener) private {\n        TimeHolder(getEventsHistory()).emitListenerRemoved(listener);\n    }\n\n    function _emitFeatureFeeTaken(address _from, address _to, uint _amount) private {\n        TimeHolder(getEventsHistory()).emitFeatureFeeTaken(_from, _to, _amount);\n    }\n\n    function _emitError(uint e) private returns (uint) {\n        TimeHolder(getEventsHistory()).emitError(e);\n        return e;\n    }\n\n    function() {\n        revert();\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[{"name":"who","type":"address"},{"name":"amount","type":"uint256"}],"name":"emitWithdrawShares","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitWithdrawShares(address,uint256)","signatureHash":"0561de9b"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address","description":"address."},{"name":"_sharesContract","type":"address","description":"ERC20 token address to act as shares."},{"name":"_wallet","type":"address"},{"name":"_feeWallet","type":"address"}],"name":"init","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Init TimeHolder contract.     *","signature":"init(address,address,address,address)","signatureHash":"06552ff3"},{"constant":true,"inputs":[],"name":"shareholdersCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"number of shareholders","notice":"Number of shareholders","signature":"shareholdersCount()","signatureHash":"1638a3fb"},{"constant":true,"inputs":[],"name":"totalSupply","payable":false,"stateMutability":"view","type":"function","signature":"totalSupply()","signatureHash":"18160ddd"},{"constant":false,"inputs":[{"name":"_amount","type":"uint256","description":"amount of shares to withdraw."}],"name":"withdrawShares","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Withdraw shares from the contract, updating the possesion proof in active period.","signature":"withdrawShares(uint256)","signatureHash":"19810f3c"},{"constant":false,"inputs":[{"name":"listener","type":"address"}],"name":"emitListenerRemoved","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitListenerRemoved(address)","signatureHash":"1c3a19ed"},{"constant":false,"inputs":[{"name":"_limitAmount","type":"uint256","description":"is limit"}],"name":"setLimit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","notice":"Setter deposit/withdraw limit","signature":"setLimit(uint256)","signatureHash":"27ea6f2b"},{"constant":false,"inputs":[{"name":"who","type":"address"},{"name":"amount","type":"uint256"}],"name":"emitDeposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitDeposit(address,uint256)","signatureHash":"28ba84ca"},{"constant":false,"inputs":[{"name":"_address","type":"address","description":"to deposit and prove for."},{"name":"_amount","type":"uint256","description":"amount of shares to deposit, or 0 to just prove."}],"name":"depositFor","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Deposit own shares and prove possession for arbitrary shareholder. Amount should be less than or equal to caller current allowance value.     * Proof should be repeated for each active period. To prove possesion without depositing more shares, specify 0 amount.     * This function meant to be used by some backend application to prove shares possesion of arbitrary shareholders.","signature":"depositFor(address,uint256)","signatureHash":"2f4f21e2"},{"constant":false,"inputs":[{"name":"listener","type":"address"}],"name":"emitListenerAdded","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitListenerAdded(address)","signatureHash":"3864a9a9"},{"constant":true,"inputs":[],"name":"totalShares","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"total amount of shares","notice":"Total amount of shares","signature":"totalShares()","signatureHash":"3a98ef39"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Finalize ownership pass.     * Can only be called by pending owner.","signature":"claimContractOwnership()","signatureHash":"4592cd1d"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32","description":"is a manager's identifier. 0x0 is not allowed."}],"name":"lookupManager","payable":false,"stateMutability":"view","type":"function","details":"Returns manager's address by its identifier (type).","notice":"Will crash if no manager in the system with given identifier.","signature":"lookupManager(bytes32)","signatureHash":"4fe59012"},{"constant":true,"inputs":[],"name":"wallet","payable":false,"stateMutability":"view","type":"function","notice":"Gets an associated wallet for the time holder","signature":"wallet()","signatureHash":"521eb273"},{"constant":true,"inputs":[],"name":"contractsManager","payable":false,"stateMutability":"view","type":"function","signature":"contractsManager()","signatureHash":"53253d31"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"address of the next owner. 0x0 is not allowed."}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Prepares ownership pass.     * Can only be called by current owner.","signature":"changeContractOwnership(address)","signatureHash":"557f4bc9"},{"constant":true,"inputs":[],"name":"pendingContractOwner","payable":false,"stateMutability":"view","type":"function","signature":"pendingContractOwner()","signatureHash":"5aa77d3c"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"setEventsHistory(address)","signatureHash":"6521afd7"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address","description":"contracts manager. 0x0 is not allowed."}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Setter for ContractsManager. Force overrides currect manager.","signature":"setContractsManager(address)","signatureHash":"71d3b573"},{"constant":true,"inputs":[],"name":"sharesContract","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","return":"address of shares contract","notice":"Contract address of shares","signature":"sharesContract()","signatureHash":"7bc1ed63"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"destroy()","signatureHash":"83197ef0"},{"constant":false,"inputs":[{"name":"_feeWallet","type":"address"}],"name":"setFeeWallet","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","notice":"Sets fee wallet address.","signature":"setFeeWallet(address)","signatureHash":"90d49b9d"},{"constant":true,"inputs":[{"name":"_address","type":"address","description":"shareholder address."}],"name":"depositBalance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"shares amount.","notice":"Returns shares amount deposited by a particular shareholder.","signature":"depositBalance(address)","signatureHash":"956501bb"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_amount","type":"uint256"}],"name":"emitFeatureFeeTaken","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitFeatureFeeTaken(address,address,uint256)","signatureHash":"9826ad69"},{"constant":false,"inputs":[{"name":"_listener","type":"address"}],"name":"removeListener","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"removeListener(address)","signatureHash":"9bc5741f"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"the next contract owner"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Direct ownership pass without change/claim pattern. Can be invoked only by current contract owner","return":"`true` if success, `false` otherwise","signature":"transferContractOwnership(address)","signatureHash":"a843c51f"},{"constant":true,"inputs":[],"name":"getLimit","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"limit","notice":"Returns deposit/withdraw limit","signature":"getLimit()","signatureHash":"b295a00e"},{"constant":false,"inputs":[{"name":"_amount","type":"uint256","description":"amount of shares to deposit, or 0 to just prove."}],"name":"deposit","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Deposit shares and prove possession. Amount should be less than or equal to current allowance value.     * Proof should be repeated for each active period. To prove possesion without depositing more shares, specify 0 amount.","signature":"deposit(uint256)","signatureHash":"b6b55f25"},{"constant":true,"inputs":[],"name":"contractOwner","payable":false,"stateMutability":"view","type":"function","signature":"contractOwner()","signatureHash":"ce606ee0"},{"constant":false,"inputs":[{"name":"_listener","type":"address"}],"name":"addListener","payable":false,"stateMutability":"nonpayable","type":"function","signature":"addListener(address)","signatureHash":"d5b50252"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","payable":false,"stateMutability":"nonpayable","type":"function","signature":"withdrawnTokens(address[],address)","signatureHash":"d8f9659b"},{"constant":false,"inputs":[{"name":"error","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitError(uint256)","signatureHash":"df26ca08"},{"constant":false,"inputs":[{"name":"_account","type":"address","description":"holder of deposits, will pay for using a features"},{"name":"_amount","type":"uint256","description":"size of a fee"}],"name":"takeFeatureFee","outputs":[{"name":"resultCode","type":"uint256","description":"result code of the operation"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Provides a way to support getting additional fee for using features of the system.","return":"resultCode result code of the operation","signature":"takeFeatureFee(address,uint256)","signatureHash":"eca87918"},{"constant":true,"inputs":[],"name":"feeWallet","payable":false,"stateMutability":"view","type":"function","notice":"Gets an associated fee wallet for the time holder","signature":"feeWallet()","signatureHash":"f25f4b56"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","payable":false,"stateMutability":"view","type":"function","signature":"isAuthorized(address)","signatureHash":"fe9fbb80"},{"constant":true,"inputs":[],"name":"getEventsHistory","payable":false,"stateMutability":"view","type":"function","signature":"getEventsHistory()","signatureHash":"fff10aba"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback","inputs":[]},{"anonymous":false,"inputs":[{"indexed":false,"name":"who","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"Deposit","type":"event","signature":"Deposit(address,uint256)","signatureHash":"e1fffcc4"},{"anonymous":false,"inputs":[{"indexed":false,"name":"who","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"WithdrawShares","type":"event","signature":"WithdrawShares(address,uint256)","signatureHash":"65acde03"},{"anonymous":false,"inputs":[{"indexed":false,"name":"listener","type":"address"}],"name":"ListenerAdded","type":"event","signature":"ListenerAdded(address)","signatureHash":"f4b5d797"},{"anonymous":false,"inputs":[{"indexed":false,"name":"listener","type":"address"}],"name":"ListenerRemoved","type":"event","signature":"ListenerRemoved(address)","signatureHash":"f8719b53"},{"anonymous":false,"inputs":[{"indexed":false,"name":"self","type":"address"},{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"FeatureFeeTaken","type":"event","signature":"FeatureFeeTaken(address,address,address,uint256)","signatureHash":"2943030e"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event","signature":"Error(address,uint256)","signatureHash":"9cf38cf2"}]}
