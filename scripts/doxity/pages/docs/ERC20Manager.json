{"fileName":"/contracts/core/erc20/ERC20Manager.sol","name":"ERC20Manager","abi":[{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"}],"name":"init","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_token","type":"address"},{"name":"_name","type":"bytes32"},{"name":"_symbol","type":"bytes32"},{"name":"_url","type":"bytes32"},{"name":"_decimals","type":"uint8"},{"name":"_ipfsHash","type":"bytes32"},{"name":"_swarmHash","type":"bytes32"}],"name":"addToken","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"getTokenBySymbol","outputs":[{"name":"tokenAddress","type":"address"},{"name":"name","type":"bytes32"},{"name":"symbol","type":"bytes32"},{"name":"url","type":"bytes32"},{"name":"decimals","type":"uint8"},{"name":"ipfsHash","type":"bytes32"},{"name":"swarmHash","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_addresses","type":"address[]"}],"name":"getTokens","outputs":[{"name":"_tokensAddresses","type":"address[]"},{"name":"_names","type":"bytes32[]"},{"name":"_symbols","type":"bytes32[]"},{"name":"_urls","type":"bytes32[]"},{"name":"_decimalsArr","type":"uint8[]"},{"name":"_ipfsHashes","type":"bytes32[]"},{"name":"_swarmHashes","type":"bytes32[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32"}],"name":"lookupManager","outputs":[{"name":"manager","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"contractsManager","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"pendingContractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_token","type":"address"}],"name":"removeToken","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_token","type":"address"}],"name":"getTokenMetaData","outputs":[{"name":"_tokenAddress","type":"address"},{"name":"_name","type":"bytes32"},{"name":"_symbol","type":"bytes32"},{"name":"_url","type":"bytes32"},{"name":"_decimals","type":"uint8"},{"name":"_ipfsHash","type":"bytes32"},{"name":"_swarmHash","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_id","type":"uint256"}],"name":"getAddressById","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_token","type":"address"}],"name":"isTokenExists","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"tokensCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_token","type":"address"},{"name":"_newToken","type":"address"},{"name":"_name","type":"bytes32"},{"name":"_symbol","type":"bytes32"},{"name":"_url","type":"bytes32"},{"name":"_decimals","type":"uint8"},{"name":"_ipfsHash","type":"bytes32"},{"name":"_swarmHash","type":"bytes32"}],"name":"setToken","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_token","type":"address"}],"name":"isTokenValid","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"contractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"removeTokenBySymbol","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"error","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getTokenAddresses","outputs":[{"name":"","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32"}],"name":"getTokenAddressBySymbol","outputs":[{"name":"tokenAddress","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_tokenVerifier","type":"address"}],"name":"setTokenVerifier","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getEventsHistory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"name","type":"bytes32"},{"indexed":false,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"url","type":"bytes32"},{"indexed":false,"name":"decimals","type":"uint8"},{"indexed":false,"name":"ipfsHash","type":"bytes32"},{"indexed":false,"name":"swarmHash","type":"bytes32"}],"name":"LogAddToken","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"oldToken","type":"address"},{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"name","type":"bytes32"},{"indexed":false,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"url","type":"bytes32"},{"indexed":false,"name":"decimals","type":"uint8"},{"indexed":false,"name":"ipfsHash","type":"bytes32"},{"indexed":false,"name":"swarmHash","type":"bytes32"}],"name":"LogTokenChange","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"name","type":"bytes32"},{"indexed":false,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"url","type":"bytes32"},{"indexed":false,"name":"decimals","type":"uint8"},{"indexed":false,"name":"ipfsHash","type":"bytes32"},{"indexed":false,"name":"swarmHash","type":"bytes32"}],"name":"LogRemoveToken","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldName","type":"bytes32"},{"indexed":false,"name":"newName","type":"bytes32"}],"name":"LogTokenNameChange","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldSymbol","type":"bytes32"},{"indexed":false,"name":"newSymbol","type":"bytes32"}],"name":"LogTokenSymbolChange","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldUrl","type":"bytes32"},{"indexed":false,"name":"newUrl","type":"bytes32"}],"name":"LogTokenUrlChange","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldIpfsHash","type":"bytes32"},{"indexed":false,"name":"newIpfsHash","type":"bytes32"}],"name":"LogTokenIpfsHashChange","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldSwarmHash","type":"bytes32"},{"indexed":false,"name":"newSwarmHash","type":"bytes32"}],"name":"LogTokenSwarmHashChange","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event"}],"source":"pragma solidity ^0.4.11;\n\nimport \"../common/BaseManager.sol\";\nimport {ERC20Interface as Asset} from \"./ERC20Interface.sol\";\nimport \"./ERC20ManagerEmitter.sol\";\n\ncontract ERC20TokenVerifier {\n    function verify(address token) returns (bool);\n}\n\ncontract ERC20Manager is ERC20ManagerEmitter, BaseManager {\n\n    event LogAddToken(\n    address token,\n    bytes32 name,\n    bytes32 symbol,\n    bytes32 url,\n    uint8 decimals,\n    bytes32 ipfsHash,\n    bytes32 swarmHash\n    );\n\n    event LogTokenChange (\n    address oldToken,\n    address token,\n    bytes32 name,\n    bytes32 symbol,\n    bytes32 url,\n    uint8 decimals,\n    bytes32 ipfsHash,\n    bytes32 swarmHash\n    );\n\n    event LogRemoveToken(\n    address token,\n    bytes32 name,\n    bytes32 symbol,\n    bytes32 url,\n    uint8 decimals,\n    bytes32 ipfsHash,\n    bytes32 swarmHash\n    );\n\n    event LogTokenNameChange(address token, bytes32 oldName, bytes32 newName);\n    event LogTokenSymbolChange(address token, bytes32 oldSymbol, bytes32 newSymbol);\n    event LogTokenUrlChange(address token, bytes32 oldUrl, bytes32 newUrl);\n    event LogTokenIpfsHashChange(address token, bytes32 oldIpfsHash, bytes32 newIpfsHash);\n    event LogTokenSwarmHashChange(address token, bytes32 oldSwarmHash, bytes32 newSwarmHash);\n\n    uint constant ERROR_ERCMANAGER_INVALID_INVOCATION = 13000;\n    uint constant ERROR_ERCMANAGER_INVALID_STATE = 13001;\n    uint constant ERROR_ERCMANAGER_TOKEN_SYMBOL_NOT_EXISTS = 13002;\n    uint constant ERROR_ERCMANAGER_TOKEN_NOT_EXISTS = 13003;\n    uint constant ERROR_ERCMANAGER_TOKEN_SYMBOL_ALREADY_EXISTS = 13004;\n    uint constant ERROR_ERCMANAGER_TOKEN_ALREADY_EXISTS = 13005;\n    uint constant ERROR_ERCMANAGER_TOKEN_UNCHANGED = 13006;\n\n    StorageInterface.AddressesSet tokenAddresses;\n    StorageInterface.Bytes32AddressMapping tokenBySymbol;\n    StorageInterface.AddressBytes32Mapping name;\n    StorageInterface.AddressBytes32Mapping symbol;\n    StorageInterface.AddressBytes32Mapping url;\n    StorageInterface.AddressBytes32Mapping ipfsHash;\n    StorageInterface.AddressBytes32Mapping swarmHash;\n    StorageInterface.AddressUIntMapping decimals;\n    StorageInterface.Address tokenVerifier;\n\n    function ERC20Manager(Storage _store, bytes32 _crate) BaseManager(_store, _crate) {\n        tokenAddresses.init('tokenAddresses');\n        tokenBySymbol.init('tokeBySymbol');\n        name.init('name');\n        symbol.init('symbol');\n        url.init('url');\n        ipfsHash.init('ipfsHash');\n        swarmHash.init('swarmHash');\n        decimals.init('decimals');\n        tokenVerifier.init('tokenVerifier');\n    }\n\n    function init(address _contractsManager) onlyContractOwner returns (uint) {\n        BaseManager.init(_contractsManager, \"ERC20Manager\");\n\n        return OK;\n    }\n\n    function setTokenVerifier(address _tokenVerifier) onlyContractOwner {\n        store.set(tokenVerifier, _tokenVerifier);\n    }\n\n    /// @dev Allows owner to add a new token to the registry.\n    /// @param _token Address of new token.\n    /// @param _name Name of new token.\n    /// @param _symbol Symbol for new token.\n    /// @param _url Token's project URL.\n    /// @param _decimals Number of decimals, divisibility of new token.\n    /// @param _ipfsHash IPFS hash of token icon.\n    /// @param _swarmHash Swarm hash of token icon.\n    function addToken(\n        address _token,\n        bytes32 _name,\n        bytes32 _symbol,\n        bytes32 _url,\n        uint8 _decimals,\n        bytes32 _ipfsHash,\n        bytes32 _swarmHash)\n    returns (uint) {\n        if (isTokenExists(_token)) {\n            return _emitError(ERROR_ERCMANAGER_TOKEN_ALREADY_EXISTS);\n        }\n\n        if (isTokenSymbolExists(_symbol)) {\n            return _emitError(ERROR_ERCMANAGER_TOKEN_SYMBOL_ALREADY_EXISTS);\n        }\n\n        if (!isTokenValid(_token)) {\n            return _emitError(ERROR_ERCMANAGER_INVALID_INVOCATION);\n        }\n\n        store.add(tokenAddresses,_token);\n        store.set(tokenBySymbol,_symbol,_token);\n        store.set(name,_token,_name);\n        store.set(symbol,_token,_symbol);\n        store.set(url,_token,_url);\n        store.set(decimals,_token,_decimals);\n        store.set(ipfsHash,_token,_ipfsHash);\n        store.set(swarmHash,_token,_swarmHash);\n\n        LogAddToken(_token, _name, _symbol, _url, _decimals, _ipfsHash, _swarmHash);\n        return OK;\n    }\n\n    function setToken(\n        address _token,\n        address _newToken,\n        bytes32 _name,\n        bytes32 _symbol,\n        bytes32 _url,\n        uint8 _decimals,\n        bytes32 _ipfsHash,\n        bytes32 _swarmHash)\n    public\n    onlyAuthorized\n    returns (uint)\n    {\n        if (!isTokenExists(_token)) {\n            return _emitError(ERROR_ERCMANAGER_TOKEN_NOT_EXISTS);\n        }\n\n        if (!isTokenValid(_newToken)) {\n            return _emitError(ERROR_ERCMANAGER_INVALID_INVOCATION);\n        }\n\n        bool changed;\n        if(_symbol != store.get(symbol,_token)) {\n            if (store.get(tokenBySymbol,_symbol) == address(0)) {\n                store.set(tokenBySymbol,store.get(symbol,_token),address(0));\n                if(_token != _newToken) {\n                    store.set(tokenBySymbol,_symbol,_newToken);\n                    store.set(symbol,_newToken,_symbol);\n                } else {\n                    store.set(tokenBySymbol,_symbol,_token);\n                    store.set(symbol,_token,_symbol);\n                }\n                changed = true;\n            } else {\n                return _emitError(ERROR_ERCMANAGER_TOKEN_UNCHANGED);\n            }\n        }\n        if(_token != _newToken) {\n            Asset(_newToken).totalSupply();\n            store.set(tokenAddresses,_token,_newToken);\n            if(!changed) {\n                store.set(tokenBySymbol,_symbol,_newToken);\n                store.set(symbol,_newToken,_symbol);\n            }\n            store.set(name,_newToken,_name);\n            store.set(url,_newToken,_url);\n            store.set(decimals,_newToken,_decimals);\n            store.set(ipfsHash,_newToken,_ipfsHash);\n            store.set(swarmHash,_newToken,_swarmHash);\n            _token = _newToken;\n            changed = true;\n        }\n\n        if(store.get(name,_token) != _name) {\n            store.set(name,_token,_name);\n            changed = true;\n        }\n\n        if(store.get(decimals,_token) != _decimals) {\n            store.set(decimals,_token,_decimals);\n            changed = true;\n        }\n        if(store.get(url,_token) != _url) {\n            store.set(url,_token,_url);\n            changed = true;\n        }\n        if(store.get(ipfsHash,_token) != _ipfsHash) {\n            store.set(ipfsHash,_token,_ipfsHash);\n            changed = true;\n        }\n        if(store.get(swarmHash,_token) != _swarmHash) {\n            store.set(swarmHash,_token,_swarmHash);\n            changed = true;\n        }\n\n        if(changed) {\n            LogTokenChange(_token, _newToken, _name, _symbol, _url, _decimals, _ipfsHash, _swarmHash);\n            return OK;\n        }\n\n        return _emitError(ERROR_ERCMANAGER_TOKEN_UNCHANGED);\n    }\n\n    /// @dev Allows owner to remove an existing token from the registry.\n    /// @param _token Address of existing token.\n    function removeToken(address _token) onlyAuthorized returns (uint) {\n        if (!isTokenExists(_token)) {\n            return _emitError(ERROR_ERCMANAGER_TOKEN_NOT_EXISTS);\n        }\n\n        return removeTokenInt(_token);\n    }\n\n    /// @dev Allows owner to remove an existing token from the registry.\n    /// @param _symbol Symbol of existing token.\n    function removeTokenBySymbol(bytes32 _symbol) onlyAuthorized returns (uint) {\n        if (!isTokenSymbolExists(_symbol)) {\n            return _emitError(ERROR_ERCMANAGER_TOKEN_SYMBOL_NOT_EXISTS);\n        }\n\n        return removeTokenInt(store.get(tokenBySymbol,_symbol));\n    }\n\n    /// @dev Allows owner to remove an existing token from the registry.\n    /// @param _token Address of existing token.\n    function removeTokenInt(address _token) internal returns (uint) {\n        LogRemoveToken(\n        _token,\n        store.get(name,_token),\n        store.get(symbol,_token),\n        store.get(url,_token),\n        uint8(store.get(decimals,_token)),\n        store.get(ipfsHash,_token),\n        store.get(swarmHash,_token)\n        );\n\n        store.set(tokenBySymbol,store.get(symbol,_token),address(0));\n        store.remove(tokenAddresses,_token);\n        return OK;\n    }\n\n    function getAddressById(uint _id) constant returns (address) {\n        return store.get(tokenAddresses, _id);\n    }\n\n    /// @dev Provides a registered token's address when given the token symbol.\n    /// @param _symbol Symbol of registered token.\n    /// @return Token's address.\n    function getTokenAddressBySymbol(bytes32 _symbol) constant returns (address tokenAddress) {\n        return store.get(tokenBySymbol,_symbol);\n    }\n\n    /// @dev Provides a registered token's metadata, looked up by address.\n    /// @param _token Address of registered token.\n    /// @return Token metadata.\n    function getTokenMetaData(address _token) constant\n    returns (\n      address _tokenAddress,\n      bytes32 _name,\n      bytes32 _symbol,\n      bytes32 _url,\n      uint8 _decimals,\n      bytes32 _ipfsHash,\n      bytes32 _swarmHash\n    )\n    {\n        if (!isTokenExists(_token)) {\n            return;\n        }\n\n        _name = store.get(name,_token);\n        _symbol = store.get(symbol,_token);\n        _url = store.get(url,_token);\n        _decimals = uint8(store.get(decimals,_token));\n        _ipfsHash = store.get(ipfsHash,_token);\n        _swarmHash = store.get(swarmHash,_token);\n\n        return (_token, _name, _symbol, _url, _decimals, _ipfsHash, _swarmHash);\n    }\n\n    function tokensCount() constant returns (uint) {\n        return store.count(tokenAddresses);\n    }\n\n    function getTokens(address[] _addresses) constant\n    returns (\n      address[] _tokensAddresses,\n      bytes32[] _names,\n      bytes32[] _symbols,\n      bytes32[] _urls,\n      uint8[] _decimalsArr,\n      bytes32[] _ipfsHashes,\n      bytes32[] _swarmHashes\n    )\n    {\n        if (_addresses.length == 0) {\n            _addresses = getTokenAddresses();\n        }\n        _tokensAddresses = _addresses;\n        _names = new bytes32[](_addresses.length);\n        _symbols = new bytes32[](_addresses.length);\n        _urls = new bytes32[](_addresses.length);\n        _decimalsArr = new uint8[](_addresses.length);\n        _ipfsHashes = new bytes32[](_addresses.length);\n        _swarmHashes = new bytes32[](_addresses.length);\n\n        for (uint i = 0; i < _addresses.length; i++) {\n            _names[i] = store.get(name, _addresses[i]);\n            _symbols[i] = store.get(symbol, _addresses[i]);\n            _urls[i] = store.get(url, _addresses[i]);\n            _decimalsArr[i] = uint8(store.get(decimals, _addresses[i]));\n            _ipfsHashes[i] = store.get(ipfsHash, _addresses[i]);\n            _swarmHashes[i] = store.get(swarmHash, _addresses[i]);\n        }\n\n        return (_tokensAddresses, _names, _symbols, _urls, _decimalsArr, _ipfsHashes, _swarmHashes);\n    }\n\n    /// @dev Provides a registered token's metadata, looked up by symbol.\n    /// @param _symbol Symbol of registered token.\n    /// @return Token metadata.\n    function getTokenBySymbol(bytes32 _symbol) constant\n    returns (\n      address tokenAddress,\n      bytes32 name,\n      bytes32 symbol,\n      bytes32 url,\n      uint8 decimals,\n      bytes32 ipfsHash,\n      bytes32 swarmHash\n    )\n    {\n        if (!isTokenSymbolExists(_symbol)) {\n          return;\n        }\n\n        address _token = store.get(tokenBySymbol,_symbol);\n        return getTokenMetaData(_token);\n    }\n\n    /// @dev Returns an array containing all token addresses.\n    /// @return Array of token addresses.\n    function getTokenAddresses() constant returns (address[]) {\n        return store.get(tokenAddresses);\n    }\n\n    function _emitError(uint e) private returns (uint)   {\n        ERC20Manager(getEventsHistory()).emitError(e);\n        return e;\n    }\n\n    function isTokenExists(address _token) constant returns (bool) {\n        return store.includes(tokenAddresses, _token);\n    }\n\n    function isTokenValid(address _token) constant returns (bool) {\n      if (store.get(tokenVerifier) != 0x0) {\n          ERC20TokenVerifier verifier = ERC20TokenVerifier(store.get(tokenVerifier));\n          return verifier.verify(_token);\n      }\n\n      return true;\n    }\n\n    function isTokenSymbolExists(bytes32 _symbol) private constant returns (bool) {\n        return (store.get(tokenBySymbol, _symbol) != address(0));\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"}],"name":"init","payable":false,"stateMutability":"nonpayable","type":"function","signature":"init(address)","signatureHash":"19ab453c"},{"constant":false,"inputs":[{"name":"_token","type":"address","description":"Address of new token."},{"name":"_name","type":"bytes32","description":"Name of new token."},{"name":"_symbol","type":"bytes32","description":"Symbol for new token."},{"name":"_url","type":"bytes32","description":"Token's project URL."},{"name":"_decimals","type":"uint8","description":"Number of decimals, divisibility of new token."},{"name":"_ipfsHash","type":"bytes32","description":"IPFS hash of token icon."},{"name":"_swarmHash","type":"bytes32","description":"Swarm hash of token icon."}],"name":"addToken","payable":false,"stateMutability":"nonpayable","type":"function","details":"Allows owner to add a new token to the registry.","signature":"addToken(address,bytes32,bytes32,bytes32,uint8,bytes32,bytes32)","signatureHash":"1e6154a2"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"Symbol of registered token."}],"name":"getTokenBySymbol","outputs":[{"name":"tokenAddress","type":"address"},{"name":"name","type":"bytes32"},{"name":"symbol","type":"bytes32"},{"name":"url","type":"bytes32"},{"name":"decimals","type":"uint8"},{"name":"ipfsHash","type":"bytes32"},{"name":"swarmHash","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function","details":"Provides a registered token's metadata, looked up by symbol.","return":"Token metadata.","signature":"getTokenBySymbol(bytes32)","signatureHash":"1f76fa34"},{"constant":true,"inputs":[{"name":"_addresses","type":"address[]"}],"name":"getTokens","payable":false,"stateMutability":"view","type":"function","signature":"getTokens(address[])","signatureHash":"273a94aa"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Finalize ownership pass.     * Can only be called by pending owner.","signature":"claimContractOwnership()","signatureHash":"4592cd1d"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32","description":"is a manager's identifier. 0x0 is not allowed."}],"name":"lookupManager","payable":false,"stateMutability":"view","type":"function","details":"Returns manager's address by its identifier (type).","notice":"Will crash if no manager in the system with given identifier.","signature":"lookupManager(bytes32)","signatureHash":"4fe59012"},{"constant":true,"inputs":[],"name":"contractsManager","payable":false,"stateMutability":"view","type":"function","signature":"contractsManager()","signatureHash":"53253d31"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"address of the next owner. 0x0 is not allowed."}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Prepares ownership pass.     * Can only be called by current owner.","signature":"changeContractOwnership(address)","signatureHash":"557f4bc9"},{"constant":true,"inputs":[],"name":"pendingContractOwner","payable":false,"stateMutability":"view","type":"function","signature":"pendingContractOwner()","signatureHash":"5aa77d3c"},{"constant":false,"inputs":[{"name":"_token","type":"address","description":"Address of existing token."}],"name":"removeToken","payable":false,"stateMutability":"nonpayable","type":"function","details":"Allows owner to remove an existing token from the registry.","signature":"removeToken(address)","signatureHash":"5fa7b584"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"setEventsHistory(address)","signatureHash":"6521afd7"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address","description":"contracts manager. 0x0 is not allowed."}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Setter for ContractsManager. Force overrides currect manager.","signature":"setContractsManager(address)","signatureHash":"71d3b573"},{"constant":true,"inputs":[{"name":"_token","type":"address","description":"Address of registered token."}],"name":"getTokenMetaData","outputs":[{"name":"_tokenAddress","type":"address"},{"name":"_name","type":"bytes32"},{"name":"_symbol","type":"bytes32"},{"name":"_url","type":"bytes32"},{"name":"_decimals","type":"uint8"},{"name":"_ipfsHash","type":"bytes32"},{"name":"_swarmHash","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function","details":"Provides a registered token's metadata, looked up by address.","return":"Token metadata.","signature":"getTokenMetaData(address)","signatureHash":"7abccac9"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"destroy()","signatureHash":"83197ef0"},{"constant":true,"inputs":[{"name":"_id","type":"uint256"}],"name":"getAddressById","payable":false,"stateMutability":"view","type":"function","signature":"getAddressById(uint256)","signatureHash":"8d80c922"},{"constant":true,"inputs":[{"name":"_token","type":"address"}],"name":"isTokenExists","payable":false,"stateMutability":"view","type":"function","signature":"isTokenExists(address)","signatureHash":"9ed4fa5a"},{"constant":true,"inputs":[],"name":"tokensCount","payable":false,"stateMutability":"view","type":"function","signature":"tokensCount()","signatureHash":"a64ed8ba"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"the next contract owner"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Direct ownership pass without change/claim pattern. Can be invoked only by current contract owner","return":"`true` if success, `false` otherwise","signature":"transferContractOwnership(address)","signatureHash":"a843c51f"},{"constant":false,"inputs":[{"name":"_token","type":"address"},{"name":"_newToken","type":"address"},{"name":"_name","type":"bytes32"},{"name":"_symbol","type":"bytes32"},{"name":"_url","type":"bytes32"},{"name":"_decimals","type":"uint8"},{"name":"_ipfsHash","type":"bytes32"},{"name":"_swarmHash","type":"bytes32"}],"name":"setToken","payable":false,"stateMutability":"nonpayable","type":"function","signature":"setToken(address,address,bytes32,bytes32,bytes32,uint8,bytes32,bytes32)","signatureHash":"b2c3f8a2"},{"constant":true,"inputs":[{"name":"_token","type":"address"}],"name":"isTokenValid","payable":false,"stateMutability":"view","type":"function","signature":"isTokenValid(address)","signatureHash":"c15e26ba"},{"constant":true,"inputs":[],"name":"contractOwner","payable":false,"stateMutability":"view","type":"function","signature":"contractOwner()","signatureHash":"ce606ee0"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","payable":false,"stateMutability":"nonpayable","type":"function","signature":"withdrawnTokens(address[],address)","signatureHash":"d8f9659b"},{"constant":false,"inputs":[{"name":"_symbol","type":"bytes32","description":"Symbol of existing token."}],"name":"removeTokenBySymbol","payable":false,"stateMutability":"nonpayable","type":"function","details":"Allows owner to remove an existing token from the registry.","signature":"removeTokenBySymbol(bytes32)","signatureHash":"db236e24"},{"constant":false,"inputs":[{"name":"error","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitError(uint256)","signatureHash":"df26ca08"},{"constant":true,"inputs":[],"name":"getTokenAddresses","outputs":[{"name":"","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function","details":"Returns an array containing all token addresses.","return":"Array of token addresses.","signature":"getTokenAddresses()","signatureHash":"ee8c24b8"},{"constant":true,"inputs":[{"name":"_symbol","type":"bytes32","description":"Symbol of registered token."}],"name":"getTokenAddressBySymbol","outputs":[{"name":"tokenAddress","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Provides a registered token's address when given the token symbol.","return":"Token's address.","signature":"getTokenAddressBySymbol(bytes32)","signatureHash":"fa7fdeb7"},{"constant":false,"inputs":[{"name":"_tokenVerifier","type":"address"}],"name":"setTokenVerifier","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"setTokenVerifier(address)","signatureHash":"fd9541a9"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","payable":false,"stateMutability":"view","type":"function","signature":"isAuthorized(address)","signatureHash":"fe9fbb80"},{"constant":true,"inputs":[],"name":"getEventsHistory","payable":false,"stateMutability":"view","type":"function","signature":"getEventsHistory()","signatureHash":"fff10aba"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"name","type":"bytes32"},{"indexed":false,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"url","type":"bytes32"},{"indexed":false,"name":"decimals","type":"uint8"},{"indexed":false,"name":"ipfsHash","type":"bytes32"},{"indexed":false,"name":"swarmHash","type":"bytes32"}],"name":"LogAddToken","type":"event","signature":"LogAddToken(address,bytes32,bytes32,bytes32,uint8,bytes32,bytes32)","signatureHash":"73609df9"},{"anonymous":false,"inputs":[{"indexed":false,"name":"oldToken","type":"address"},{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"name","type":"bytes32"},{"indexed":false,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"url","type":"bytes32"},{"indexed":false,"name":"decimals","type":"uint8"},{"indexed":false,"name":"ipfsHash","type":"bytes32"},{"indexed":false,"name":"swarmHash","type":"bytes32"}],"name":"LogTokenChange","type":"event","signature":"LogTokenChange(address,address,bytes32,bytes32,bytes32,uint8,bytes32,bytes32)","signatureHash":"53fe1ea0"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"name","type":"bytes32"},{"indexed":false,"name":"symbol","type":"bytes32"},{"indexed":false,"name":"url","type":"bytes32"},{"indexed":false,"name":"decimals","type":"uint8"},{"indexed":false,"name":"ipfsHash","type":"bytes32"},{"indexed":false,"name":"swarmHash","type":"bytes32"}],"name":"LogRemoveToken","type":"event","signature":"LogRemoveToken(address,bytes32,bytes32,bytes32,uint8,bytes32,bytes32)","signatureHash":"4ccdcd88"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldName","type":"bytes32"},{"indexed":false,"name":"newName","type":"bytes32"}],"name":"LogTokenNameChange","type":"event","signature":"LogTokenNameChange(address,bytes32,bytes32)","signatureHash":"06f06174"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldSymbol","type":"bytes32"},{"indexed":false,"name":"newSymbol","type":"bytes32"}],"name":"LogTokenSymbolChange","type":"event","signature":"LogTokenSymbolChange(address,bytes32,bytes32)","signatureHash":"d58677b3"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldUrl","type":"bytes32"},{"indexed":false,"name":"newUrl","type":"bytes32"}],"name":"LogTokenUrlChange","type":"event","signature":"LogTokenUrlChange(address,bytes32,bytes32)","signatureHash":"d09074eb"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldIpfsHash","type":"bytes32"},{"indexed":false,"name":"newIpfsHash","type":"bytes32"}],"name":"LogTokenIpfsHashChange","type":"event","signature":"LogTokenIpfsHashChange(address,bytes32,bytes32)","signatureHash":"e46a8f26"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"oldSwarmHash","type":"bytes32"},{"indexed":false,"name":"newSwarmHash","type":"bytes32"}],"name":"LogTokenSwarmHashChange","type":"event","signature":"LogTokenSwarmHashChange(address,bytes32,bytes32)","signatureHash":"a9fd2168"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event","signature":"Error(address,uint256)","signatureHash":"9cf38cf2"}]}
