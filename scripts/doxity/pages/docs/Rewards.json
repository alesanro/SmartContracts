{"title":"Universal decentralized ERC20 tokens rewards contract. * One ERC20 token serves as a shares, and any number of other ERC20 tokens serve as rewards(assets). Rewards distribution are divided in periods, the only thing that shareholder needs to do in order to take part in distribution is prove to rewards contract that he possess certain amount of shares before period closes. Prove is made through allowing rewards contract to take shares from the shareholder, and then depositing it through a call to rewards contract. Proof is needed for every period. * When calculating rewards distribution, resulting amount is always rounded down. * In order to be able to deposit shares, user needs to create allowance for wallet contract, using standard ERC20 approve() function, so that contract can take shares from the user, when user makes a dpeosit. * Users can withdraw their shares at any moment, but only remaining shares will be used for rewards distribution. Users can withdraw their accumulated rewards at any moment. * State flow:  1. Period closed, next period started;  2. Reward assets registered for last closed preiod;  3. Rewards distributed for closed period;  4. Shares deposited into current period;  5. Repeat. * Note: all the non constant functions return false instead of throwing in case if state change didn't happen yet.","fileName":"/contracts/reward/Rewards.sol","name":"Rewards","abi":[{"constant":false,"inputs":[{"name":"e","type":"uint256"}],"name":"_emitError","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_assetAddress","type":"address"},{"name":"_address","type":"address"}],"name":"rewardsFor","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"addr","type":"address"},{"name":"amount","type":"uint256"},{"name":"total","type":"uint256"}],"name":"emitWithdrawn","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_part","type":"uint256"}],"name":"emitDepositStored","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"asset","type":"address"},{"name":"addr","type":"address"},{"name":"amount","type":"uint256"}],"name":"_emitWithdrawnReward","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"asset","type":"address"},{"name":"addr","type":"address"},{"name":"amount","type":"uint256"}],"name":"emitWithdrawnReward","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"_emitPeriodClosed","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_assetAddress","type":"address"},{"name":"_period","type":"uint256"}],"name":"assetBalanceInPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"},{"name":"_wallet","type":"address"},{"name":"_targetPlatform","type":"address"},{"name":"_closeIntervalDays","type":"uint256"}],"name":"init","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32"}],"name":"lookupManager","outputs":[{"name":"manager","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"closePeriod","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"wallet","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"contractsManager","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_period","type":"uint256"}],"name":"periodUnique","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_asset","type":"address"},{"name":"_amount","type":"uint256"}],"name":"withdrawReward","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"withdrawAllRewardsTotal","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"pendingContractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"addr","type":"address"},{"name":"amount","type":"uint256"},{"name":"total","type":"uint256"}],"name":"_emitWithdrawn","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getAssets","outputs":[{"name":"result","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"periodsLength","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address"}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_assetAddress","type":"address"},{"name":"_address","type":"address"},{"name":"_period","type":"uint256"}],"name":"isCalculatedFor","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"assetAddress","type":"address"}],"name":"_emitAssetRegistered","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"lastClosedPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_maxSharesTransfer","type":"uint256"}],"name":"setMaxSharesTransfer","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_address","type":"address"}],"name":"depositBalance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"storeDeposits","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_period","type":"uint256"}],"name":"totalDepositInPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getCloseInterval","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_period","type":"uint256"}],"name":"getPeriodStartDate","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"assetAddress","type":"address"}],"name":"emitAssetRegistered","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"shareholder","type":"address"}],"name":"getRewardsLeft","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_address","type":"address"},{"name":"_period","type":"uint256"}],"name":"depositBalanceInPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"contractOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_part","type":"uint256"}],"name":"_emitDepositStored","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"lastPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_closeInterval","type":"uint256"}],"name":"setCloseInterval","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_period","type":"uint256"}],"name":"isClosed","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"error","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"emitPeriodClosed","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_asset","type":"address"}],"name":"withdrawRewardTotal","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getMaxSharesTransfer","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getEventsHistory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":false,"name":"addr","type":"address"},{"indexed":false,"name":"amount","type":"uint256"},{"indexed":false,"name":"total","type":"uint256"}],"name":"WithdrawnSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"asset","type":"address"},{"indexed":false,"name":"addr","type":"address"},{"indexed":false,"name":"amountReward","type":"uint256"}],"name":"WithdrawnRewardSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_part","type":"uint256"}],"name":"DepositStored","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"assetAddress","type":"address"}],"name":"AssetRegistered","type":"event"},{"anonymous":false,"inputs":[],"name":"PeriodClosed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event"}],"source":"pragma solidity ^0.4.11;\n\nimport {TimeHolderInterface as TimeHolder} from \"../timeholder/TimeHolderInterface.sol\";\nimport \"../core/erc20/ERC20Interface.sol\";\nimport \"../assets/AssetsManagerInterface.sol\";\nimport \"../assets/PlatformsManagerInterface.sol\";\nimport \"../timeholder/DepositWalletInterface.sol\";\nimport \"../core/common/Managed.sol\";\nimport \"../core/common/Deposits.sol\";\nimport \"../reward/RewardsEmitter.sol\";\n\n/**\n* @title Defines interface for managers that can store any tokens and use for that purpose wallets\n* instead of keeping tokens on their own address. Keeps this contracts updatable with ease.\n*/\ncontract WalletBackedManagerInterface {\n    function wallet() constant returns (address);\n}\n\n/**\n * @title Universal decentralized ERC20 tokens rewards contract.\n *\n * One ERC20 token serves as a shares, and any number of other ERC20 tokens serve as rewards(assets).\n * Rewards distribution are divided in periods, the only thing that shareholder needs to do in\n * order to take part in distribution is prove to rewards contract that he possess certain amount\n * of shares before period closes. Prove is made through allowing rewards contract to take shares\n * from the shareholder, and then depositing it through a call to rewards contract. Proof is needed\n * for every period.\n *\n * When calculating rewards distribution, resulting amount is always rounded down.\n *\n * In order to be able to deposit shares, user needs to create allowance for wallet contract, using\n * standard ERC20 approve() function, so that contract can take shares from the user, when user\n * makes a dpeosit.\n *\n * Users can withdraw their shares at any moment, but only remaining shares will be used for\n * rewards distribution.\n * Users can withdraw their accumulated rewards at any moment.\n *\n * State flow:\n *   1. Period closed, next period started;\n *   2. Reward assets registered for last closed preiod;\n *   3. Rewards distributed for closed period;\n *   4. Shares deposited into current period;\n *   5. Repeat.\n *\n * Note: all the non constant functions return false instead of throwing in case if state change\n * didn't happen yet.\n */\ncontract Rewards is Deposits, RewardsEmitter {\n\n    uint constant ERROR_REWARD_NOT_FOUND = 9000;\n    uint constant ERROR_REWARD_INVALID_PARAMETER = 90001;\n    uint constant ERROR_REWARD_INVALID_INVOCATION = 9002;\n    uint constant ERROR_REWARD_INVALID_STATE = 9003;\n    uint constant ERROR_REWARD_INVALID_PERIOD = 9004;\n    uint constant ERROR_REWARD_NO_REWARDS_LEFT = 9005;\n    uint constant ERROR_REWARD_ASSET_TRANSFER_FAILED = 9006;\n    uint constant ERROR_REWARD_ALREADY_CALCULATED = 9007;\n    uint constant ERROR_REWARD_CALCULATION_FAILED = 9008;\n    uint constant ERROR_REWARD_CANNOT_CLOSE_PERIOD = 9009;\n    uint constant ERROR_REWARD_ASSET_ALREADY_REGISTERED = 9010;\n\n    StorageInterface.UInt closeInterval;\n    StorageInterface.UInt maxSharesTransfer;\n    StorageInterface.AddressAddressUIntMapping rewards;\n    StorageInterface.AddressUIntMapping rewardsLeft;\n    StorageInterface.UInt periods;\n    StorageInterface.UIntBoolMapping closed;\n    StorageInterface.UIntUIntMapping startDate;\n    StorageInterface.UIntUIntMapping totalShares;\n    StorageInterface.UIntAddressUIntMapping shares;\n    StorageInterface.UIntUIntMapping shareholdersCount;\n    StorageInterface.UIntAddressUIntMapping assetBalances;\n    StorageInterface.UIntAddressAddressBoolMapping calculated;\n    StorageInterface.Address targetPlatform;\n    StorageInterface.Address walletStorage;\n\n    function Rewards(Storage _store, bytes32 _crate) Deposits(_store, _crate) {\n        closeInterval.init('closeInterval');\n        maxSharesTransfer.init('maxSharesTransfer');\n        rewards.init('rewards');\n        rewardsLeft.init('rewardsLeft');\n        periods.init('periods');\n        totalShares.init('totalShares');\n        shareholdersCount.init('shareholdersCount');\n        closed.init('closed');\n        startDate.init('startDate');\n        assetBalances.init('assetBalances');\n        calculated.init('calculated');\n        shares.init('shares');\n        targetPlatform.init('targetPlatform');\n        walletStorage.init(\"rewardsWalletStorage\");\n    }\n\n    /**\n     * Sets ContractManager contract and period minimum length.\n     * Starts the first period.\n     *\n     * Can be set only once.\n     *\n     * @param _contractsManager contracts Manager contract address.\n     * @param _closeIntervalDays period minimum length, in days.\n     *\n     * @return result code, @see Errors\n     */\n    function init(address _contractsManager, address _wallet, address _targetPlatform, uint _closeIntervalDays) onlyContractOwner returns (uint) {\n        uint result = BaseManager.init(_contractsManager, \"Rewards\");\n\n        store.set(closeInterval, _closeIntervalDays);\n        store.set(targetPlatform, _targetPlatform);\n        store.set(walletStorage, _wallet);\n\n        // do not update default values if reinitialization\n        if (REINITIALIZED != result) {\n            store.set(startDate,0,now);\n            store.set(maxSharesTransfer,30);\n        }\n\n        return OK;\n    }\n\n    /**\n    * @dev Gets wallet address used to store tokens\n    *\n    * @return wallet address\n    */\n    function wallet() public constant returns (address) {\n        return store.get(walletStorage);\n    }\n\n    function getCloseInterval() constant returns(uint) {\n        return store.get(closeInterval);\n    }\n\n    function setCloseInterval(uint _closeInterval) onlyAuthorized returns(uint) {\n        store.set(closeInterval,_closeInterval);\n        return OK;\n    }\n\n    function getMaxSharesTransfer() constant returns(uint) {\n        return store.get(maxSharesTransfer);\n    }\n\n    function setMaxSharesTransfer(uint _maxSharesTransfer) onlyAuthorized returns (uint) {\n        store.set(maxSharesTransfer,_maxSharesTransfer);\n        return OK;\n    }\n\n    function getRewardsLeft(address shareholder) constant returns(uint) {\n        return store.get(rewardsLeft,shareholder);\n    }\n\n    function periodsLength() constant returns(uint) {\n        return store.get(periods);\n    }\n\n    function periodUnique(uint _period) constant returns(uint) {\n        if(_period == lastPeriod()) {\n            return store.count(shareholders);\n        } else {\n            return store.get(shareholdersCount,_period);\n        }\n    }\n\n    function getAssets() constant returns(address[] result) {\n        address _targetPlatform = store.get(targetPlatform);\n        AssetsManagerInterface assetsManager = AssetsManagerInterface(lookupManager(\"AssetsManager\"));\n        address chronoMintWallet = WalletBackedManagerInterface(lookupManager(\"LOCManager\")).wallet();\n        uint assetsCount = assetsManager.getAssetsForOwnerCount(_targetPlatform, chronoMintWallet);\n        result = new address[](assetsCount);\n        bytes32 symbol;\n        for (uint idx = 0; idx < assetsCount; ++idx) {\n            symbol = assetsManager.getAssetForOwnerAtIndex(_targetPlatform, chronoMintWallet, idx);\n            result[idx] = assetsManager.getAssetBySymbol(symbol);\n        }\n    }\n\n    /**\n     * Close current active period and start the new period.\n     *\n     * Can only be done if period was active longer than minimum length.\n     *\n     * @return success.\n     */\n    function closePeriod() onlyAuthorized returns (uint resultCode) {\n        uint period = lastPeriod();\n        if ((store.get(startDate,period) + (store.get(closeInterval) * 1 days)) > now) {\n            return _emitError(ERROR_REWARD_CANNOT_CLOSE_PERIOD);\n        }\n\n        uint _totalSharesPeriod = store.get(totalSharesStorage);\n        uint _shareholdersCount = store.count(shareholders);\n        store.set(totalShares, period, _totalSharesPeriod);\n        store.set(shareholdersCount, period, _shareholdersCount);\n        address[] memory assets = getAssets();\n        if (assets.length != 0) {\n            for (uint i = 0; i < assets.length; i++) {\n                uint result = registerAsset(assets[i], period);\n                if (OK != result) {\n                    // do not interrupt, just emit an Event\n                    emitError(result);\n                }\n            }\n        }\n        store.set(periods,++period);\n        store.set(startDate,period,now);\n        resultCode = storeDeposits(assets);\n        if (resultCode == OK) {\n            _emitPeriodClosed();\n        }\n    }\n\n    function getPeriodStartDate(uint _period) constant returns (uint) {\n        return store.get(startDate, _period);\n    }\n\n    /**\n    *  @return error code and still left shares. `sharesLeft` is actual only\n    *  if `errorCode` == OK, otherwise `sharesLeft` must be ignored.\n    */\n    function storeDeposits() onlyAuthorized returns (uint resultCode) {\n        resultCode = storeDeposits(getAssets());\n    }\n\n    function storeDeposits(address[] assets) internal returns (uint result) {\n        uint period = lastClosedPeriod();\n        uint period_end = getPeriodStartDate(lastPeriod());\n        StorageInterface.Iterator memory iterator = store.listIterator(shareholders);\n        uint amount;\n        uint j;\n        for(uint i = 0; store.canGetNextWithIterator(shareholders, iterator); i++) {\n            address shareholder = store.getNextWithIterator(shareholders, iterator);\n            amount = 0;\n            StorageInterface.Iterator memory iterator2 = store.listIterator(deposits,bytes32(shareholder));\n            for(j = 0; store.canGetNextWithIterator(deposits, iterator2); j++) {\n                uint id = store.getNextWithIterator(deposits,iterator2);\n                uint timestamp = store.get(timestamps,shareholder,id);\n                if(timestamp <= period_end) {\n                    amount += store.get(amounts,shareholder,id);\n                }\n            }\n            for(j = 0; j < assets.length; j++) {\n                result = calculateRewardFor(assets[j],shareholder,amount,period);\n                if(OK != result) {\n                    _emitError(result);\n                }\n            }\n            store.set(shares,period,shareholder,amount);\n        }\n\n        store.set(closed, period, true);\n\n        return OK;\n    }\n\n    function registerAsset(address _asset, uint _period) internal returns (uint) {\n        if (store.get(sharesContractStorage) == _asset) {\n            return _emitError(ERROR_REWARD_ASSET_ALREADY_REGISTERED);\n        }\n        uint period_balance = store.get(assetBalances,_period,_asset);\n        if (period_balance != 0) {\n            return _emitError(ERROR_REWARD_ASSET_ALREADY_REGISTERED);\n        }\n\n        uint balance = ERC20Interface(_asset).balanceOf(wallet());\n        uint left = store.get(rewardsLeft,_asset);\n        store.set(assetBalances,_period,_asset,balance - left);\n        store.set(rewardsLeft,_asset,balance);\n\n        _emitAssetRegistered(address(_asset));\n        return OK;\n    }\n\n    function calculateRewardFor(address _assetAddress, address _address, uint _amount, uint _period) internal returns (uint e) {\n        uint assetBalance = store.get(assetBalances,_period,_assetAddress);\n        if (assetBalance == 0) {\n            return ERROR_REWARD_CALCULATION_FAILED;\n        }\n\n        if (store.get(calculated,_period,_assetAddress,_address)) {\n            return ERROR_REWARD_ALREADY_CALCULATED;\n        }\n\n        uint totalSharesPeriod = store.get(totalShares,_period);\n        uint reward =  assetBalance * _amount / totalSharesPeriod;\n        uint cur_reward = store.get(rewards,_assetAddress,_address);\n        store.set(rewards,_assetAddress,_address,cur_reward + reward);\n        store.set(calculated,_period,_assetAddress,_address,true);\n\n        return OK;\n    }\n\n    /**\n     * Withdraw accumulated reward of a specified rewards asset.\n     *\n     * Withdrawal is made for caller and total amount.\n     *\n     * @param _asset registered rewards asset contract address.\n     *\n     * @return success.\n     */\n    function withdrawRewardTotal(address _asset) returns (uint) {\n        return withdrawRewardFor(_asset, msg.sender, rewardsFor(_asset, msg.sender));\n    }\n\n    /**\n     * Withdraw all accumulated rewards.\n     *\n     * Withdrawals are made for caller and total amount.\n     *\n     * @return result code.\n     */\n    function withdrawAllRewardsTotal() returns (uint) {\n        address[] memory _assets = getAssets();\n        for (uint i=0; i < _assets.length; i++) {\n            uint _rewards = rewardsFor(_assets[i], msg.sender);\n            if (_rewards > 0) {\n                uint result = withdrawRewardFor(_assets[i], msg.sender, _rewards);\n                if (OK != result) {\n                    return result;\n                }\n            }\n        }\n\n        return OK;\n    }\n\n    /**\n     * Withdraw accumulated reward of a specified rewards asset.\n     *\n     * Withdrawal is made for specified shareholder and total amount.\n     *\n     * This function meant to be used by some backend application to send rewards\n     * for arbitrary shareholders.\n     *\n     * @param _asset registered rewards asset contract address.\n     * @param _address shareholder address to withdraw for.\n     *\n     * @return success.\n     */\n    /*function withdrawRewardTotalFor(address _asset, address _address) returns (uint) {\n        return withdrawRewardFor(_asset, _address, rewardsFor(_asset, _address));\n    }*/\n\n    /**\n     * Withdraw accumulated reward of a specified rewards asset.\n     *\n     * Withdrawal is made for caller and specified amount.\n     *\n     * @param _asset registered rewards asset contract address.\n     * @param _amount amount to withdraw.\n     *\n     * @return success.\n     */\n    function withdrawReward(address _asset, uint _amount) returns (uint) {\n        return withdrawRewardFor(_asset, msg.sender, _amount);\n    }\n\n    /**\n     * Withdraw accumulated reward of a specified rewards asset.\n     *\n     * Withdrawal is made for specified shareholder and specified amount.\n     *\n     * @param _asset registered rewards asset contract address.\n     * @param _address shareholder address to withdraw for.\n     * @param _amount amount to withdraw.\n     *\n     * @return success.\n     */\n    function withdrawRewardFor(address _asset, address _address, uint _amount) internal returns (uint) {\n        if (store.get(rewardsLeft,_asset) == 0) {\n            return _emitError(ERROR_REWARD_NO_REWARDS_LEFT);\n        }\n\n        // Assuming that transfer(amount) of unknown asset may not result in exactly\n        // amount being taken from rewards contract(i. e. fees taken) we check contracts\n        // balance before and after transfer, and proceed with the difference.\n        address _wallet = wallet();\n        uint startBalance = ERC20Interface(_asset).balanceOf(_wallet);\n        if (!DepositWalletInterface(_wallet).withdraw(_asset, _address, _amount)) {\n            return _emitError(ERROR_REWARD_ASSET_TRANSFER_FAILED);\n        }\n\n        uint endBalance = ERC20Interface(_asset).balanceOf(_wallet);\n        uint diff = startBalance - endBalance;\n        if (rewardsFor(_asset, _address) < diff) {\n            revert();\n        }\n\n        store.set(rewards,_asset,_address,store.get(rewards,_asset,_address) - diff);\n        store.set(rewardsLeft,_asset, store.get(rewardsLeft,_asset) - diff);\n\n        _emitWithdrawnReward(_asset, _address, _amount);\n        return OK;\n    }\n\n    /**\n     * Returns proven amount of shares possessed by a shareholder in a period.\n     *\n     * @param _address shareholder address.\n     * @param _period period.\n     *\n     * @return shares amount.\n     */\n    function depositBalanceInPeriod(address _address, uint _period) constant returns (uint) {\n        if(_period == lastPeriod()) {\n            return depositBalance(_address);\n        }\n        return store.get(shares,_period,_address);\n    }\n\n    /**\n     * Returns total proven amount of shares possessed by shareholders in a period.\n     *\n     * @param _period period.\n     *\n     * @return shares amount.\n     */\n    function totalDepositInPeriod(uint _period) constant returns(uint) {\n        if(_period == lastPeriod()) {\n            return store.get(totalSharesStorage);\n        }\n        return store.get(totalShares,_period);\n    }\n\n    /**\n     * Returns current active period.\n     *\n     * @return period.\n     */\n    function lastPeriod() constant returns(uint) {\n        return store.get(periods);\n    }\n\n    /**\n     * Returns last closed period.\n     *\n     * @dev throws in case if there is no closed periods yet.\n     *\n     * @return period.\n     */\n    function lastClosedPeriod() constant returns(uint) {\n        if (store.get(periods) == 0) {\n            return ERROR_REWARD_NOT_FOUND;\n        }\n        return store.get(periods) - 1;\n    }\n\n    /**\n     * Check if period is closed or not.\n     *\n     * @param _period period.\n     *\n     * @return period closing state.\n     */\n    function isClosed(uint _period) constant returns(bool) {\n        return store.get(closed,_period);\n    }\n\n    /**\n     * Returns amount of accumulated rewards assets in a period.\n     * Always 0 for active period.\n     *\n     * @param _assetAddress rewards asset contract address.\n     * @param _period period.\n     *\n     * @return assets amount.\n     */\n    function assetBalanceInPeriod(address _assetAddress, uint _period) constant returns(uint) {\n        return store.get(assetBalances,_period,_assetAddress);\n    }\n\n    /**\n     * Check if shareholder have calculated rewards in a period.\n     *\n     * @param _assetAddress rewards asset contract address.\n     * @param _address shareholder address.\n     * @param _period period.\n     *\n     * @return reward calculation state.\n     */\n    function isCalculatedFor(address _assetAddress, address _address, uint _period) constant returns(bool) {\n        return store.get(calculated,_period,_assetAddress,_address);\n    }\n\n    /**\n     * Returns accumulated asset rewards available for withdrawal for shareholder.\n     *\n     * @param _assetAddress rewards asset contract address.\n     * @param _address shareholder address.\n     *\n     * @return rewards amount.\n     */\n    function rewardsFor(address _assetAddress, address _address) constant returns(uint) {\n        return store.get(rewards, _assetAddress, _address);\n    }\n\n    // Even emitter util functions\n\n    function _emitWithdrawnReward(address asset, address addr, uint amount) {\n        Rewards(getEventsHistory()).emitWithdrawnReward(asset, addr, amount);\n    }\n\n    function _emitWithdrawn(address addr, uint amount, uint total) {\n        Rewards(getEventsHistory()).emitWithdrawn(addr, amount, total);\n    }\n\n    function _emitDepositStored(uint _part) {\n        Rewards(getEventsHistory()).emitDepositStored(_part);\n    }\n\n    function _emitAssetRegistered(address assetAddress) {\n        Rewards(getEventsHistory()).emitAssetRegistered(assetAddress);\n    }\n\n    function _emitPeriodClosed() {\n        Rewards(getEventsHistory()).emitPeriodClosed();\n    }\n\n    function _emitError(uint e) returns (uint) {\n        Rewards(getEventsHistory()).emitError(e);\n        return e;\n    }\n\n    function() {\n        revert();\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[{"name":"e","type":"uint256"}],"name":"_emitError","payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitError(uint256)","signatureHash":"06d44278"},{"constant":true,"inputs":[{"name":"_assetAddress","type":"address","description":"rewards asset contract address."},{"name":"_address","type":"address","description":"shareholder address."}],"name":"rewardsFor","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"rewards amount.","notice":"Returns accumulated asset rewards available for withdrawal for shareholder.","signature":"rewardsFor(address,address)","signatureHash":"0f09330b"},{"constant":false,"inputs":[{"name":"addr","type":"address"},{"name":"amount","type":"uint256"},{"name":"total","type":"uint256"}],"name":"emitWithdrawn","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitWithdrawn(address,uint256,uint256)","signatureHash":"1bbf65ef"},{"constant":false,"inputs":[{"name":"_part","type":"uint256"}],"name":"emitDepositStored","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitDepositStored(uint256)","signatureHash":"1bc24083"},{"constant":false,"inputs":[{"name":"asset","type":"address"},{"name":"addr","type":"address"},{"name":"amount","type":"uint256"}],"name":"_emitWithdrawnReward","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitWithdrawnReward(address,address,uint256)","signatureHash":"2f65fa59"},{"constant":false,"inputs":[{"name":"asset","type":"address"},{"name":"addr","type":"address"},{"name":"amount","type":"uint256"}],"name":"emitWithdrawnReward","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitWithdrawnReward(address,address,uint256)","signatureHash":"3752f49a"},{"constant":false,"inputs":[],"name":"_emitPeriodClosed","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitPeriodClosed()","signatureHash":"3e87a56d"},{"constant":true,"inputs":[{"name":"_assetAddress","type":"address","description":"rewards asset contract address."},{"name":"_period","type":"uint256","description":"period."}],"name":"assetBalanceInPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"assets amount.","notice":"Returns amount of accumulated rewards assets in a period. Always 0 for active period.","signature":"assetBalanceInPeriod(address,uint256)","signatureHash":"43369c59"},{"constant":false,"inputs":[],"name":"claimContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Finalize ownership pass.     * Can only be called by pending owner.","signature":"claimContractOwnership()","signatureHash":"4592cd1d"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address","description":"contracts Manager contract address."},{"name":"_wallet","type":"address"},{"name":"_targetPlatform","type":"address"},{"name":"_closeIntervalDays","type":"uint256","description":"period minimum length, in days."}],"name":"init","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"result code, @see Errors","notice":"Sets ContractManager contract and period minimum length. Starts the first period.     * Can be set only once.","signature":"init(address,address,address,uint256)","signatureHash":"46639dba"},{"constant":true,"inputs":[{"name":"_identifier","type":"bytes32","description":"is a manager's identifier. 0x0 is not allowed."}],"name":"lookupManager","payable":false,"stateMutability":"view","type":"function","details":"Returns manager's address by its identifier (type).","notice":"Will crash if no manager in the system with given identifier.","signature":"lookupManager(bytes32)","signatureHash":"4fe59012"},{"constant":false,"inputs":[],"name":"closePeriod","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Close current active period and start the new period.     * Can only be done if period was active longer than minimum length.","signature":"closePeriod()","signatureHash":"507a7328"},{"constant":true,"inputs":[],"name":"wallet","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets wallet address used to store tokens","return":"wallet address","signature":"wallet()","signatureHash":"521eb273"},{"constant":true,"inputs":[],"name":"contractsManager","payable":false,"stateMutability":"view","type":"function","signature":"contractsManager()","signatureHash":"53253d31"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"address of the next owner. 0x0 is not allowed."}],"name":"changeContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Prepares ownership pass.     * Can only be called by current owner.","signature":"changeContractOwnership(address)","signatureHash":"557f4bc9"},{"constant":true,"inputs":[{"name":"_period","type":"uint256"}],"name":"periodUnique","payable":false,"stateMutability":"view","type":"function","signature":"periodUnique(uint256)","signatureHash":"57bd8522"},{"constant":false,"inputs":[{"name":"_asset","type":"address","description":"registered rewards asset contract address."},{"name":"_amount","type":"uint256","description":"amount to withdraw."}],"name":"withdrawReward","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Withdraw accumulated reward of a specified rewards asset.     * Withdrawal is made for caller and specified amount.","signature":"withdrawReward(address,uint256)","signatureHash":"58d3232f"},{"constant":false,"inputs":[],"name":"withdrawAllRewardsTotal","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"result code.","notice":"Withdraw all accumulated rewards.     * Withdrawals are made for caller and total amount.","signature":"withdrawAllRewardsTotal()","signatureHash":"590f8c93"},{"constant":true,"inputs":[],"name":"pendingContractOwner","payable":false,"stateMutability":"view","type":"function","signature":"pendingContractOwner()","signatureHash":"5aa77d3c"},{"constant":false,"inputs":[{"name":"_eventsHistory","type":"address"}],"name":"setEventsHistory","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"setEventsHistory(address)","signatureHash":"6521afd7"},{"constant":false,"inputs":[{"name":"addr","type":"address"},{"name":"amount","type":"uint256"},{"name":"total","type":"uint256"}],"name":"_emitWithdrawn","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitWithdrawn(address,uint256,uint256)","signatureHash":"670bcab1"},{"constant":true,"inputs":[],"name":"getAssets","payable":false,"stateMutability":"view","type":"function","signature":"getAssets()","signatureHash":"67e4ac2c"},{"constant":true,"inputs":[],"name":"periodsLength","payable":false,"stateMutability":"view","type":"function","signature":"periodsLength()","signatureHash":"6abe602d"},{"constant":false,"inputs":[{"name":"_contractsManager","type":"address","description":"contracts manager. 0x0 is not allowed."}],"name":"setContractsManager","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Setter for ContractsManager. Force overrides currect manager.","signature":"setContractsManager(address)","signatureHash":"71d3b573"},{"constant":true,"inputs":[{"name":"_assetAddress","type":"address","description":"rewards asset contract address."},{"name":"_address","type":"address","description":"shareholder address."},{"name":"_period","type":"uint256","description":"period."}],"name":"isCalculatedFor","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","return":"reward calculation state.","notice":"Check if shareholder have calculated rewards in a period.","signature":"isCalculatedFor(address,address,uint256)","signatureHash":"76807249"},{"constant":false,"inputs":[{"name":"assetAddress","type":"address"}],"name":"_emitAssetRegistered","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitAssetRegistered(address)","signatureHash":"77e9f6fc"},{"constant":false,"inputs":[],"name":"destroy","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"destroy()","signatureHash":"83197ef0"},{"constant":true,"inputs":[],"name":"lastClosedPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","details":"throws in case if there is no closed periods yet.","return":"period.","notice":"Returns last closed period.","signature":"lastClosedPeriod()","signatureHash":"8632779c"},{"constant":false,"inputs":[{"name":"_maxSharesTransfer","type":"uint256"}],"name":"setMaxSharesTransfer","payable":false,"stateMutability":"nonpayable","type":"function","signature":"setMaxSharesTransfer(uint256)","signatureHash":"896efbd6"},{"constant":true,"inputs":[{"name":"_address","type":"address","description":"shareholder address."}],"name":"depositBalance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"shares amount.","notice":"Returns shares amount deposited by a particular shareholder.","signature":"depositBalance(address)","signatureHash":"956501bb"},{"constant":false,"inputs":[],"name":"storeDeposits","outputs":[{"name":"resultCode","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"error code and still left shares. `sharesLeft` is actual only if `errorCode` == OK, otherwise `sharesLeft` must be ignored.","signature":"storeDeposits()","signatureHash":"98af444e"},{"constant":true,"inputs":[{"name":"_period","type":"uint256","description":"period."}],"name":"totalDepositInPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"shares amount.","notice":"Returns total proven amount of shares possessed by shareholders in a period.","signature":"totalDepositInPeriod(uint256)","signatureHash":"9a24159b"},{"constant":true,"inputs":[],"name":"getCloseInterval","payable":false,"stateMutability":"view","type":"function","signature":"getCloseInterval()","signatureHash":"9d3c7370"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"the next contract owner"}],"name":"transferContractOwnership","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Direct ownership pass without change/claim pattern. Can be invoked only by current contract owner","return":"`true` if success, `false` otherwise","signature":"transferContractOwnership(address)","signatureHash":"a843c51f"},{"constant":true,"inputs":[{"name":"_period","type":"uint256"}],"name":"getPeriodStartDate","payable":false,"stateMutability":"view","type":"function","signature":"getPeriodStartDate(uint256)","signatureHash":"aef54664"},{"constant":false,"inputs":[{"name":"assetAddress","type":"address"}],"name":"emitAssetRegistered","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitAssetRegistered(address)","signatureHash":"b1a97052"},{"constant":true,"inputs":[{"name":"shareholder","type":"address"}],"name":"getRewardsLeft","payable":false,"stateMutability":"view","type":"function","signature":"getRewardsLeft(address)","signatureHash":"be0ab3cb"},{"constant":true,"inputs":[{"name":"_address","type":"address","description":"shareholder address."},{"name":"_period","type":"uint256","description":"period."}],"name":"depositBalanceInPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"shares amount.","notice":"Returns proven amount of shares possessed by a shareholder in a period.","signature":"depositBalanceInPeriod(address,uint256)","signatureHash":"cce53fc4"},{"constant":true,"inputs":[],"name":"contractOwner","payable":false,"stateMutability":"view","type":"function","signature":"contractOwner()","signatureHash":"ce606ee0"},{"constant":false,"inputs":[{"name":"_part","type":"uint256"}],"name":"_emitDepositStored","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"_emitDepositStored(uint256)","signatureHash":"d1ddb8b3"},{"constant":true,"inputs":[],"name":"lastPeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","return":"period.","notice":"Returns current active period.","signature":"lastPeriod()","signatureHash":"d340ef8a"},{"constant":false,"inputs":[{"name":"_closeInterval","type":"uint256"}],"name":"setCloseInterval","payable":false,"stateMutability":"nonpayable","type":"function","signature":"setCloseInterval(uint256)","signatureHash":"d5309c60"},{"constant":true,"inputs":[{"name":"_period","type":"uint256","description":"period."}],"name":"isClosed","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","return":"period closing state.","notice":"Check if period is closed or not.","signature":"isClosed(uint256)","signatureHash":"d5c78a28"},{"constant":false,"inputs":[{"name":"tokens","type":"address[]"},{"name":"_to","type":"address"}],"name":"withdrawnTokens","payable":false,"stateMutability":"nonpayable","type":"function","signature":"withdrawnTokens(address[],address)","signatureHash":"d8f9659b"},{"constant":false,"inputs":[{"name":"error","type":"uint256"}],"name":"emitError","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitError(uint256)","signatureHash":"df26ca08"},{"constant":false,"inputs":[],"name":"emitPeriodClosed","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","signature":"emitPeriodClosed()","signatureHash":"e29065d6"},{"constant":false,"inputs":[{"name":"_asset","type":"address","description":"registered rewards asset contract address."}],"name":"withdrawRewardTotal","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"success.","notice":"Withdraw accumulated reward of a specified rewards asset.     * Withdrawal is made for caller and total amount.","signature":"withdrawRewardTotal(address)","signatureHash":"f6b003e5"},{"constant":true,"inputs":[],"name":"getMaxSharesTransfer","payable":false,"stateMutability":"view","type":"function","signature":"getMaxSharesTransfer()","signatureHash":"fe82b458"},{"constant":true,"inputs":[{"name":"key","type":"address"}],"name":"isAuthorized","payable":false,"stateMutability":"view","type":"function","signature":"isAuthorized(address)","signatureHash":"fe9fbb80"},{"constant":true,"inputs":[],"name":"getEventsHistory","payable":false,"stateMutability":"view","type":"function","signature":"getEventsHistory()","signatureHash":"fff10aba"},{"inputs":[{"name":"_store","type":"address"},{"name":"_crate","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback","inputs":[]},{"anonymous":false,"inputs":[{"indexed":false,"name":"addr","type":"address"},{"indexed":false,"name":"amount","type":"uint256"},{"indexed":false,"name":"total","type":"uint256"}],"name":"WithdrawnSuccess","type":"event","signature":"WithdrawnSuccess(address,uint256,uint256)","signatureHash":"9733cd8d"},{"anonymous":false,"inputs":[{"indexed":false,"name":"asset","type":"address"},{"indexed":false,"name":"addr","type":"address"},{"indexed":false,"name":"amountReward","type":"uint256"}],"name":"WithdrawnRewardSuccess","type":"event","signature":"WithdrawnRewardSuccess(address,address,uint256)","signatureHash":"9e059fe0"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_part","type":"uint256"}],"name":"DepositStored","type":"event","signature":"DepositStored(uint256)","signatureHash":"8df23d40"},{"anonymous":false,"inputs":[{"indexed":false,"name":"assetAddress","type":"address"}],"name":"AssetRegistered","type":"event","signature":"AssetRegistered(address)","signatureHash":"0700b0f4"},{"anonymous":false,"inputs":[],"name":"PeriodClosed","type":"event","signature":"PeriodClosed()","signatureHash":"3a273a33"},{"anonymous":false,"inputs":[{"indexed":true,"name":"self","type":"address"},{"indexed":false,"name":"errorCode","type":"uint256"}],"name":"Error","type":"event","signature":"Error(address,uint256)","signatureHash":"9cf38cf2"}]}
